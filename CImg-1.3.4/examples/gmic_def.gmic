#@gmic
#
#  File        : gmic_def.gmic
#                ( G'MIC default custom commands )
#
#  Description : Define recognized commands for the G'MIC interpreter
#                and available filters for GIMP plug-in.
#                ( http://gmic.sourceforge.net )
#
#                This file is also a part of the CImg Library project.
#                ( http://cimg.sourceforge.net )
#
#  Location    : If you are using the G'MIC plug-in for GIMP, and made
#                a filter refresh via Internet, then a copy of this file
#                should be found in the folder :
#
#                  $HOME/.gmic_def.xxxx    (on Unix-based OS).
#                  %APPDATA/.gmic_def.xxxx (on Windows-based OS).
#
#  Usage       : gmic [-m gmic_def.gmic] (...)
#
#  Copyright   : David Tschumperle
#                ( http://www.greyc.ensicaen.fr/~dtschump/ )
#
#  License     : CeCILL v2.0
#                ( http://www.cecill.info/licences/Licence_CeCILL_V2-en.html )
#
#  This software is governed by the CeCILL  license under French law and
#  abiding by the rules of distribution of free software.  You can  use,
#  modify and/ or redistribute the software under the terms of the CeCILL
#  license as circulated by CEA, CNRS and INRIA at the following URL
#  "http://www.cecill.info".
#
#  As a counterpart to the access to the source code and  rights to copy,
#  modify and redistribute granted by the license, users are provided only
#  with a limited warranty  and the software's author,  the holder of the
#  economic rights,  and the successive licensors  have only  limited
#  liability.
#
#  In this respect, the user's attention is drawn to the risks associated
#  with loading,  using,  modifying and/or developing or reproducing the
#  software by the user in light of its specific status of free software,
#  that may mean  that it is complicated to manipulate,  and  that  also
#  therefore means  that it is reserved for developers  and  experienced
#  professionals having in-depth computer knowledge. Users are therefore
#  encouraged to load and test the software's suitability as regards their
#  requirements in conditions enabling the security of their systems and/or
#  data to be ensured and,  more generally, to use and operate it in the
#  same conditions as regards security.
#
#  The fact that you are presently reading this means that you have had
#  knowledge of the CeCILL license and that you accept its terms.
#

#--- General syntax rules for a G'MIC command file : ---------------------------------------------------------------------
#
# - Each line starting with '#' is a comment line.
#
# - Each line starting with 'command_name : ' starts a new G'MIC custom command.
#
# - Any other line is considered as the continuation of the previous started G'MIC custom command.
#
# - A comment line as '#@gmic command_name : arguments : description' will be used in the command line
#   version of G'MIC as the helper for this command (displayed when invoking 'gmic -help').
#
# - A comment line starting with '#@gimp' will be used to in the GIMP plug-in version of G'MIC to define
#   a new filter entry.
#
# - Same rules apply for comment line starting with '#@gimp_xx' to define filters translated in language
#   'xx' (e.g. 'en','fr'...).
#
#   More precisely, the syntax of a '#@gimp' comment line can be :
#
#   '#@gimp Group name'
#
# or
#
#   '#@gimp Command name : command, preview_command, parameter = typedef, parameter2 = typedef'
#   '#@gimp : parameter3 = typedef, parameter4 = typedef ...., parameterN = typedef'
#
#   where :
#
#      'command' is the G'MIC command name called to process the image.
#
#      'preview_command' is the G'MIC command name called to process the preview.
#
#           Note that you can optionally specify a float-valued factor>=0 between parentheses at the end of
#           the 'preview_command' to force the default zoom factor used by the GIMP preview for this filter.
#           Use (0) for a 1:1 preview, (1) for previewing the whole image, (2) for 1/2 image and so on...
#
#      'parameter = typedef' tells about the names, types and default values of the filter parameters.
#
#           'typedef' can be :
#
#      - 'float(default_value,min_value,max_value)'       : Add a float-valued parameter (as a GUI float slider).
#      - 'int(default_value,min_value,max_value)'         : Add a integer parameter (as a GUI integer slider).
#      - 'bool(default_value={0,1,false,true})'           : Add a boolean parameter (0 or 1) (as a GUI checkbutton).
#      - 'choice(_default_indice,Choice0,..,ChoiceN)'     : Add a integer parameter (as a GUI combobox).
#      - 'text(_default text)'                            : Add a text parameter (as a GUI text entry).
#      - 'file(_default_filename)'                        : Add a filename parameter (as a GUI filechooser).
#      - 'folder(_default_foldername)'                    : Add a foldername parameter (as a GUI folderchooser).
#      - 'color(defaultR,defaultG,defaultB,_defaultA)'    : Add R,G,B[,A] parameters (as a GUI colorchooser).
#      - 'note(_Comment)'                                 : Display a label, but do not add a new parameter.
#      - 'link(_Comment,URL)'                             : Display a label that link to a specified URL.
#      - 'value(value)'                                   : Do not display a GUI widget, but set a parameter value.
#
#   Type separators '()' can be replaced by '[]' or '{}' if necessary (for instance if parentheses are required in
#   an argument of the typedef, e.g in a text). You can also replace 'typedef' by '_typedef' to tell the plug-in not
#   to update the image preview when the corresponding parameter is modified.
#
#   Use '_none_' as a special command or preview_command to tell the plug-in that nothing has to be done.
#
#-----------------------------------------------------------------------------------------------------------------------

#--------------------------------------------------
#
# Useful global tools
#
#--------------------------------------------------

#@gmic outputw : : Output selected images by overwritting their original location (eq. to '-ow').
outputw :
  -if {@#>1} -e[0--3] "Output image$? as their initial location."
  -else -e[0--3] "Output image$? as its initial location."
  -endif
  -v - -repeat @#
    ({@{-1,n}})
    -if {@{-1,{@{-1,w}-1}}==42} -columns[-1] 0,{@{-1,w}-2} -endif   # Remove ending '*' if necessary.
    -o[-2] @{-1,t}
    -rm[-1]
  -mv[-1] 0 -done -v +

#@gmic ow : eq. to '-outputw'. :
ow :
  -outputw

#@gmic outputp : 'prefix' : Output selected images as prefixed versions of their original filenames (eq. to '-op').
outputp : -skip ${1="_"}
  -if {@#>1} -e[0--3] "Output image$? as their initial locations, prefixed by '$1'."
  -else -e[0--3] "Output image$? as its initial location, prefixed by '$1'."
  -endif
  -v - -repeat @#
    ({@{-1,f}$1@{-1,b}.@{-1,x}})
    -if {@{-1,{@{-1,w}-1}}==42} -columns[-1] 0,{@{-1,w}-2} -endif   # Remove ending '*' if necessary.
    -o[-2] @{-1,t}
    -rm[-1]
  -mv[-1] 0 -done -v +

#@gmic op : eq. to '-outputp'. :
op : -skip ${1="_"}
  -outputp $1

#@gmic display0 : : Display selected images with value normalization off (eq. to '-d0').
display0 :
  -v -
  -p[0] 0 -p[1] 0 -p[2] 0 -p[3] 0
  -repeat @#
    -pr[0] {~0+@{-1,w}}
    -pr[1] {max(~1,@{-1,h})}
    -pr[2] {max(~2,@{-1,d})}
    -pr[3] {max(~3,@{-1,s})}
  -mv[-1] 0 -done
  -if {@#==1} -w -1,-1,0,0,@{0,n}\ (~0x~1x~2x~3)
  -elif {@#==2} -w -1,-1,0,0,@{0,n},@{-1,n}\ (~0x~1x~2x~3)
  -else -w -1,-1,0,0,@{0,n},..,@{-1,n}\ (~0x~1x~2x~3)
  -endif
  -pp[0-3]
  -v + -d
  -v - -w[] 0 -v +

#@gmic d0 : eq. to '-display0'. :
d0 :
  -display0

#@gmic split_tiles : M!=0,_N!=0,_is_homogeneous={0|1} : Split selected images as a MxN array of tiles.
split_tiles : -skip $1,${2=$1},${3=0}
  -if $3 -e[^-1] "Split image$? as an array of homogeneous tiles, with (M,N) = ($1,$2)."
  -else -e[^-1] "Split image$? as an array of tiles, with (M,N) = ($1,$2)."
  -endif
  -v - -repeat @#
    -l[-1] -s y,$2 -s x,$1 -if $3 -r [0],[0],100%,100%,0 -endif -endl
  -mv[{-$1*$2}--1] 0 -done -v +

#@gmic append_tiles : M>0,_N>0 : Append MxN selected tiles as a new image.
append_tiles : -skip $1,${2=$1}
  -e[^-1] "Append $1x$2 tile$? as new image(s)."
  -v - -repeat {@#/($1*$2)} -l[{-$1*$2}--1]
    -repeat $2 -a[-$1--1] x -mv[-1] 0 -done -a y
  -endl -mv[-1] 0 -done -v +

#@gmic replace_nan : _expression : Replace all NaN values in selected images by specified expression.
replace_nan : -skip ${1=0}
  -e[^-1] "Replace all NaN in image$? by expression $1"
  -v - -f if(i==i,i,$1) -v +

#@gmic replace_inf : _expression : Replace all infinite values in selected images by specified expression.
replace_inf : -skip ${1=0}
  -e[^-1] "Replace all infinite values in image$? by expression $1"
  -v - -f if(i==i+1,$1,i) -v +

#@gmic roundify : _gamma>=0 : Apply roundify transformation on float-valued data, with specified gamma.
roundify : -check "$1>=0"
  -e[^-1] "Roundify image$?, with gamma $1."
  -if {$1==1} -return -endif
  -v - -repeat @#
    --round[-1] 1 --[-2] [-1]
    --*[-2] 2 -abs[-1] -pow[-1] $1 -sign[-3] -*[-3,-1] -*[-2] 0.5 -+[-2,-1]
  -mv[-1] 0 -done -v +

#@gmic strcmp : string1,string2 : Compare two strings and push resulting boolean on the global stack.
strcmp :
  -v - (0,{"$1_"}) (@{-1,w},{"$2_"}) -=[-2] @{-1,w} --[-2,-1] -abs[-1] -p {!@{-1,+}} -rm[-1] -v +

#@gmic apply_pose3d : p1,..,p12 : Apply 3D pose matrix to selected 3D objects.
apply_pose3d : -skip $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12
  -e[^-1] "Apply 3D pose matrix [ $1,$2,$3,$4; $5,$6,$7,$8; $9,$10,$11,$12 ] to 3D object$?."
  -v - -repeat @# -l[-1] -s3d
    -r[2] 3,{@{2,#}/3},1,1,-1 -s[2] x
    --*[2] $5 --*[3] $6 --*[4] $7 -+[-3--1] -+[-1] $8
    --*[2] $9 --*[3] $10 --*[4] $11 -+[-3--1] -+[-1] $12
    -*[2] $1 -*[3] $2 -*[4] $3 -+[2-4] -+[2] $4
    -a[2,-2,-1] x -r[2] 1,{@{2,#}},1,1,-1
  -a y -endl -mv[-1] 0 -done -v +

#--------------------------------------------------
#
# Image characteristics
#
#--------------------------------------------------

#@gmic push_filename : "filename",_number1,_number2 : Push a numbered version of the specified filename on the global stack.
push_filename : -skip ${1="gmic"},${2=""},${3=""}
  -v - 1 -name[-1] $1 -p @{-1,f}@{-1,b}
  -if {narg($2)}
    -pr[-1] ~-1_{(($2/100000)>>0)%10}{(($2/10000)>>0)%10}{(($2/1000)>>0)%10}{(($2/100)>>0)%10}{(($2/10)>>0)%10}{$2%10}
  -endif
  -if {narg($3)}
    -pr[-1] ~-1_{(($3/100000)>>0)%10}{(($3/10000)>>0)%10}{(($3/1000)>>0)%10}{(($3/100)>>0)%10}{(($3/10)>>0)%10}{$3%10}
  -endif
  -if {narg(@{-1,x})}
    -pr[-1] ~-1.@{-1,x}
  -endif
  -rm[-1] -v +

#@gmic push_maxsize : : Push the maximal size of selected images on the global stack.
push_maxsize :
  -v - -p[0] 0 -p[1] 0 -p[2] 0 -p[3] 0
  -repeat @#
    -pr[0] {max(~0,@{-1,w})}
    -pr[1] {max(~1,@{-1,h})}
    -pr[2] {max(~2,@{-1,d})}
    -pr[3] {max(~3,@{-1,s})}
  -mv[-1] 0 -done
  -p ~0,~1,~2,~3
  -pp[0-3]
  -v +

#@gmic push_minsize : : Push the minimal size of selected images on the global stack.
push_minsize :
  -v - -p[0] 0 -p[1] 0 -p[2] 0 -p[3] 0
  -repeat @#
    -pr[0] {max(~0,@{-1,w})}
    -pr[1] {max(~1,@{-1,h})}
    -pr[2] {max(~2,@{-1,d})}
    -pr[3] {max(~3,@{-1,s})}
  -mv[-1] 0 -done
  -p ~0,~1,~2,~3
  -pp[0-3]
  -v +

#@gmic histogram_cumul : _nb_levels>0,_is_normalized={0|1} : Compute cumulative histogram of selected images.
histogram_cumul : -check "isint(${1=256}) && $1>0 && isbool(${2=0})"
  -if $2 -e[^-1] "Compute normalized cumulative histogram of image$?, using $1 levels."
  -else -e[^-1] "Compute cumulative histogram of image$?, using $1 levels." -endif
  -v - -histogram $1 -repeat @#
    -i[-2] [-1],1,1,1,0 -repeat @{-1,w} -+[-2] [-1] -shift[-1] 1 -done -rm[-1]
    -if $2 -/[-1] @{-1,M} -endif
  -mv[-1] 0 -done -v +

#@gmic direction2rgb : : Compute RGB representation of selected 2D direction fields.
direction2rgb :
  -e[^-1] "Compute RGB representation of 2D direction field$?."
  -v - -repeat @#
    -channels[-1] 0,1 -s[-1] c -complex2polar[-2,-1]
    -*[-1] 128 -/[-1] 3.14159265359 -+[-1] 256 -mod[-1] 256 -map[-1] 1
    -to_rgb[-2] -n[-2] 0,1 -*[-2,-1]
  -mv[-1] 0 -done -v +

#@gmic vector2tensor : : Convert selected vector fields to corresponding diffusion tensor fields.
vector2tensor :
  -e[^-1] "Convert vector field$? to diffusion tensor field$?."
  -v - -repeat @# -l[-1]
    -s c
    -if {@#==2} --sqr[-1] -*[-2] [-3] -sqr[-3]
    -elif {@#==3} --sqr[-2] --*[-3] [-2] --sqr[-3] -*[-5,-4] [-6] -sqr[-6]
    -else -error "Invalid image : Dimensions "@{-1,w}","@{-1,h}","@{-1,d}","@{-1,s}" does not represent a field of 2D or 3D vectors."
    -endif
    -a c
  -endl -mv[-1] 0 -done -v +

#@gmic display_fft : : Display Fourier transform of selected images, with centered log-module and argument (eq. to '-dfft').
display_fft :
  -e[^-1] "Render Fourier transform of image$? with centered log-module and argument."
  -v - -repeat @#
    -fft[-1] -complex2polar[-2,-1] -shift[-2,-1] 50%,50%,50%,0,2 -+[-2] 1 -log[-2] -n[-2,-1] 0,255 -a[-2,-1] x
  -mv[-1] 0 -done -s x,2 -v +

#@gmic dfft : eq. to '-display_fft'. :
dfft :
  -display_fft

#@gmic display_rgba : : Render selected RGBA images over a checkerboard background (eq. to '-drgba').
display_rgba :
  -e[^-1] "Render RGBA image$? over a checkerboard background."
  -v - -repeat @#
    -i[-2] (160,128;128,160) -r[-2] 16,16 -r[-2] [-1],[-1],1,3,0,2 -compose_rgba[-2,-1]
  -mv[-1] 0 -done -v +

#@gmic drgba : eq. to '-display_rgba'. :
drgba :
  -display_rgba

#@gmic display_histogram : _width>0,_height>0,_clusters>0,_max_value>0,_show_axes={0|1} : Render a channel-by-channel histogram (eq. to '-dh').
display_histogram : -check "${1=512}>0 && ${2=200}>0 && ${3=256}>0 && ${4=255}" -skip ${5=1}
  -e[^-1] "Render $1x$2 channel-by-channel histogram of image$?, with $3 clusters and maximum value $4."
  -v -
  -repeat @#
    -l[-1] -s c -histogram $3,0,$4
    --max -p @{-1,M} -rm[-1]
    -repeat @#
      $1,$2,1,1,-255 -graph[-1] [-2],3,0,~-1,0,1,0,0
      -rm[-2]
    -mv[-1] 0 -done
    -a c
    -if $5 -axes[-1] 0,$4,~-1,0,1,-128 -endif
    -pp[-1]
    -endl
    -+[-1] 255
  -mv[-1] 0 -done -v +

dh :
  -display_histogram $*

#--------------------------------------------------
#
# Contours and value variations
#
#--------------------------------------------------

#@gmic gradient_norm : : Compute gradient norm of selected images.
gradient_norm :
  -e[^-1] "Compute gradient norm of image$?."
  -v - -repeat @#
    --gradient[-1] x -sqr[-1]
    --gradient[-2] y -sqr[-1] -+[-2,-1]
    -gradient[-2] z -sqr[-2] -+[-2,-1]
    -p @{-1,s} -s[-1] c -+[-~-1--1] -pp[-1]
    -sqrt[-1]
  -mv[-1] 0 -done -v +

#@gmic gradient_orientation : _dimension={1,2,3} : Compute N-D gradient orientation of selected images.
gradient_orientation : -check "${1=3}==1 || $1==2 || $1==3"
  -e[^-1] "Compute $1-D gradient orientation of image$?."
  -v - -repeat @#
    -if {$1==1} -gradient[-1] x --abs[-1] -+[-1] 1e-8 -/[-2,-1]
    -elif {$1==2} -gradient[-1] xy --sqr[-2--1] -+[-2,-1] -+[-1] 1e-8 -sqrt[-1] -/[-3] [-1] -/[-2,-1]
    -else -gradient[-1] xyz --sqr[-3--1] -+[-3--1] -+[-1] 1e-8 -sqrt[-1] -/[-4,-3] [-1] -/[-2,-1]
    -endif
  -mv[-$1--1] 0 -done -v +

#@gmic gradient2rgb : _orientation={0|1} : Compute RGB representation of 2D gradient of selected images.
gradient2rgb : -check "isbool(${1=0})"
  -if $1 -e[^-1] "Compute RGB representation of 2D gradient orientation of image$?."
  -else -e[^-1] "Compute RGB representation of 2D gradient of image$?." -endif
  -v - -repeat @#
    -norm[-1]
    -if $1 -gradient_orientation[-1] 2 -else -gradient[-1] xy -endif
    -a[-2,-1] c -direction2rgb[-1]
  -mv[-1] 0 -done -v +

#@gmic laplacian : : Compute Laplacian of selected images.
laplacian :
  -e[^-1] "Compute Laplacian of image $?."
  -v - -repeat @#
    -hessian[-1] xxyyzz -+[-3--1]
  -mv[-1] 0 -done -v +

#@gmic gradient_derivative2 : : Compute gradient-directed 2nd derivative of image(s).
gradient_derivative2 :
  -e[^-1] "Compute gradient-directed 2nd derivative of image$?."
  -v - -repeat @#
    --gradient[-1] xyz -hessian[-4] xxxyxzyyyzzz
    --sqr[-3] -*[-10,-1] --sqr[-2] -*[-7,-1] --sqr[-1] -*[-5,-1]
    -*[-8,-7,-5] 2 -*[-8] [-3] -*[-8] [-2] -*[-7] [-3] -*[-7] [-1] -*[-5] [-2] -*[-5] [-1]
    -+[-9--4] -sqr[-3--1] -+[-3--1] -+[-1] 1e-8 -/[-2,-1]
  -mv[-1] 0 -done -v +

#@gmic curvature : : Compute isophote curvatures on selected images.
curvature :
  -e[^-1] "Compute isophote curvatures on image$?."
  -v - -repeat @#
    [-1]x2 -laplacian[-3] -gradient_derivative2[-2] --[-3,-2] -gradient_norm[-1] -+[-1] 1e-8 -/[-2,-1]
  -mv[-1] 0 -done -v +

#@gmic edges : _threshold>=0 : Estimate contours of selected images.
edges : -skip ${1=15}
  -e[^-1] "Estimate image contours of image$?, with threshold $1."
  -v - -repeat @#
    -gradient_norm[-1] -blur[-1] 0.5 -t[-1] $1% -distance[-1] 0 -equalize[-1] 256
    -negative[-1] -c[-1] 30%,70% -n[-1] 0,1
  -mv[-1] 0 -done -v +

#@gmic isophotes : _nb_levels>0 : Render isophotes of selected images on a transparent background.
isophotes : -skip ${1=64}
  -e[^-1] "Render isophote maps from images$?, with $1 levels."
  -v - -to_rgba -repeat @# -l[-1]
    --luminance -repeat $1 --isoline3d[1] {@{>,-1}*255/($1-1)} -done -rm[1] -+3d[1--1] -col3d[-1] 1,1,1
    [0],[0] -object3d[-1] [-2],0,0 -rm[-2] -*[-2,-1]
  -endl -mv[-1] 0 -done -v +

#@gmic topographic_map : _nb_levels>0,_smoothness : Render selected images as topographic maps.
topographic_map : -skip ${1=16},${2=2}
  -e[^-1] "Render topographic maps from image$?, with $1 levels and smoothness $2."
  -v - -to_rgb -repeat @#
    --blur[-1] $2 -isophotes[-1] $1 -t[-1] 0.1 -to_rgb[-1] --norm[-1]
    -line[-2,-1] 100%,0,100%,100%,1,1 -line[-2,-1] 0,100%,100%,100%,1,1
    -line[-2,-1] 0,0,100%,0,1,1 -line[-2,-1] 0,0,0,100%,1,1
    -_topographic_map0[-3--1]
    -_topographic_map[-3--1]
    -rm[-3,-1]
  -mv[-1] 0 -done -v +

_topographic_map0 :
  -repeat 4000
    -p {?(@{-1,w})},{?(@{-1,h})}
    -if {@{-1,(~-1)}==0}
      -flood[-2] ~-1,0,0,1,@{-3,(~-1,0,0)},@{-3,(~-1,0,1)},@{-3,(~-1,0,2)}
      -flood[-1] ~-1,0,0,1,1
    -endif
    -pp[-1]
  -done

_topographic_map :
  -do
    (@{-1,c}) -p @{-1,0},@{-1,1} -rm[-1]
    -if {@{-1,(~-1)}==0}
      -flood[-2] ~-1,0,0,1,@{-3,(~-1,0,0)},@{-3,(~-1,0,1)},@{-3,(~-1,0,2)}
      -flood[-1] ~-1,0,0,1,1
      -pp[-1]
    -else -pp[-1] -return
    -endif
  -while 1

#--------------------------------------------------
#
# Spatial filtering
#
#--------------------------------------------------

#@gmic blur_x : _amplitude,_borders={0|1} : Blur selected images along the X-axis.
blur_x : -skip ${1=10},${2=1}
  -_blur_n $1,$2,X,y,z

#@gmic blur_y : _amplitude,_borders={0|1} : Blur selected images along the Y-axis.
blur_y : -skip ${1=10},${2=1}
  -_blur_n $1,$2,Y,x,z

#@gmic blur_z : _amplitude,_borders={0|1} : Blur selected images along the Z-axis.
blur_z : -skip ${1=10},${2=1}
  -_blur_n $1,$2,Z,x,y

_blur_n :
  -e[^-1] "Blur image$? along the $3-axis, with amplitude $1 and border conditions $2."
  -v - -repeat @#
    -l[-1] -s $5 -repeat @#
      -l[-1] -s $4 -blur $1,$2 -a $4 -endl
    -mv[-1] 0 -done -a $5 -endl
  -mv[-1] 0 -done -v +

#@gmic blur_angular : _amplitude,_cx,_cy : Apply angular blur on selected images.
blur_angular : -skip ${1=10},${2=0.5},${3=0.5}
  -e[^-1] "Apply angular blur on image$?, with amplitude $1 and center ($2,$3)."
  -v - -euclidean2polar $2,$3,1.3,1 -expand_y 16,2 -blur_y $1 -shrink_y 16 -polar2euclidean $2,$3,1.3,1 -v +

#@gmic blur_radial : _amplitude,_cx,_cy : Apply radial blur on selected images.
blur_radial : -skip ${1=0.1},${2=0.5},${3=0.5}
  -e[^-1] "Apply radial blur on image$?, with amplitude $1 and center ($2,$3)."
  -v - -euclidean2polar $2,$3,5,1 -blur_x $1 -polar2euclidean $2,$3,5,1 -v +

#@gmic blur_linear : _amplitude1,_amplitude2,_angle=0,_borders={0|1} : Apply linear blur on selected images, with specified angle and amplitudes.
blur_linear : -skip ${1=0.2},${2=0.02},${3=0},${4=1}
  -e[^-1] "Apply linear blur on image$?, with angle $3 and amplitudes ($1,$2)."
  -v - -repeat @#
    -if {$4==1} -expand_x[-1] 16 -expand_y[-1] 16 -else -frame 16,16,0 -endif
    ($3,$3) -+[-1] 90 -=[-1] $3,1 -/[-1] 180 -*[-1] 3.14159265359 -sin[-1]
    (-1,1) (-1;1) -r[-2,-1] [-4],[-4],[-4],1,3
    --*[-1] @{-3,0} --*[-3] @{-4,1} --[-2,-1] -/[-1] $2 -sqr[-1]
    -*[-3] @{-4,0} -*[-2] @{-4,1} -+[-3,-2] -/[-2] $1 -sqr[-2]
    -+[-2,-1] -*[-1] -1 -exp[-1] -normalize_sum[-1] -rm[-2]
    -convolve_fft[-2,-1] -shrink_x[-1] 16 -shrink_y[-1] 16
  -mv[-1] 0 -done -v +

#@gmic dog : _sigma1>=0[%],_sigma2>=0[%] : Compute difference of gaussian on selected images.
dog : -skip ${1=2%},${2=3%}
  -e[^-1] "Compute difference of gaussian on image$?, with standard deviations $1 and $2."
  -v - -repeat @#
    --blur[-1] $1 -blur[-2] $2 --[-2,-1] -norm[-1]
  -mv[-1] 0 -done -v +

#@gmic split_freq : smoothness>0[%] : Split selected images into low and high frequency parts.
split_freq : -skip ${1=2%}
  -e[^-1] "Split image$? into low and high frequency parts, with smoothness $1."
  -v - -repeat @#
    --blur[-1] $1 --[-2] [-1] -reverse[-2,-1]
  -mv[-2,-1] 0 -done -v +

#@gmic compose_freq : : Compose selected low and high frequency parts into new images.
compose_freq :
  -e[^-1] "Compose low and high frequency part$? into new images."
  -v - -repeat {@#/2}
    -+[-2,-1]
  -mv[-1] 0 -done -v +

#@gmic normalize_local : _amplitude>=0,_radius>0,_n_smooth>=0[%],_a_smooth>=0[%],_cut={0|1},_min=0,_max=255 : Normalize selected images locally.
normalize_local :
  -check "${1=3}>=0 && isint(${2=16}) && $2>0 && isbool(${5=1}) && isval(${6=0}) && isval(${7=255})" -skip ${3=4%},${4=2%}
  -e[^-1] "Normalize image$? locally, with amplitude $1, radius $2, neighborhood smoothness $3 and average smoothness $4."
  -v - -repeat @#
    --l[-1] -erode {2*$2+1} -s c -min -endl
    --l[-2] -dilate {2*$2+1} -s c -max -endl
    --blur[-3] $4 -blur[-3,-2] $3
    ---[-2] [-3] -+[-1] 0.01 --[-5] [-4] -/[-5,-1]
    -*[-3,-2] {$1+1} -*[-1] -$1 -+[-3] [-1] -+[-2,-1]
    -if $5 -max[-2] $6 -min[-1] $7 -endif
    --[-1] [-2] -*[-3,-1] -+[-2,-1]
    -if $5 -c[-1] $6,$7 -endif
  -mv[-1] 0 -done -v +

#@gmic unsharp : _radius[%]>=0,_amount>=0,_threshold[%]>=0 : Apply unsharp mask on selected images.
unsharp : -check "${2=2}>=0" -skip ${1=1},${3=0}
  -e[^-1] "Apply unsharp mask on image$?, with radius $1, amount $2 and threshold $3."
  -v - -repeat @#
    --blur[-1] $1 --[-1] [-2]
    -if $3 --norm[-1] -t[-1] $3 -*[-2,-1] -endif
    -*[-1] $2 --[-2,-1]
  -mv[-1] 0 -done -v +

#@gmic unsharp_octave : _nb_scales>0,_radius[%]>=0,_amount>=0,threshold[%]>=0 : Apply octave sharpening on selected images.
unsharp_octave : -check "isint(${1=4}) && $1>0 && ${3=2}>=0" -skip ${2=1},${4=0}
  -e[^-1] "Apply octave sharpening on image$?, with $1 scales, radius $2, amount $3 and threshold $4."
  -v - -repeat @#
    -l[-1] --f 0 -p 0 -repeat $1
      --unsharp[0] {$2*2^-@{<,-1}},$3,$4 -*[-1] {2^-@{>,-1}} -pr[-1] {~-1+2^-@{>,-1}} -+[1,-1]
    -done -rm[0] -/[-1] ~-1 -pp[-1] -endl
  -mv[-1] 0 -done -v +

#@gmic convolve_fft : : Convolve selected images two-by-two through Fourier transforms.
convolve_fft :
  -e[^-1] "Convolve image$? two-by-two through Fourier transforms."
  -v - -repeat {@#/2}
    -r[-1] 100%,100%,100%,[-2],1 -r[-1] [-2],0,0,0.5,0.5,0.5,0.5 -shift[-1] -50%,-50%,-50%,0,2
    -fft[-2] -fft[-1] -shift[-1] -50%,-50%,-50%,0,2
    --*[-4] [-1] --*[-4] [-3] -+[-2,-1]
    -*[-5,-3] -*[-3,-2] --[-3,-2]
    -ifft[-2,-1] -rm[-1]
  -mv[-1] 0 -done -v +

#@gmic deconvolve_fft : : Deconvolve selected images two-by-two through Fourier transforms.
deconvolve_fft :
  -e[^-1] "Deconvolve image$? two-by-two through Fourier transforms."
  -v - -repeat {@#/2}
    -r[-1] 100%,100%,100%,[-2],1 -r[-1] [-2],0,0,0.5,0.5,0.5,0.5 -shift[-1] -50%,-50%,-50%,0,2
    -fft[-2] -fft[-1] -shift[-1] -50%,-50%,-50%,0,2
    --sqr[-2] --sqr[-2] -+[-2,-1] -+[-1] 0.0001 -/[-5--2] [-1] -rm[-1]
    --*[-3] [-2] --*[-5] [-2] --[-2,-1]
    -*[-5,-3] -*[-3,-2] -+[-3,-2]
    -ifft[-2,-1] -rm[-1]
  -mv[-1] 0 -done -v +

#@gmic bandpass : _min_freq[%],_max_freq[%] : Apply bandpass filter to selected images.
bandpass : -skip ${1=0},${2=20%}
  -e[^-1] "Apply bandpass filter [$1,$2] to image$?."
  -v - -repeat @#
    100%,100%,100% -f[-1] "sqrt((x/w-0.5)^2 + (y/h-0.5)^2 + (z/d-0.5)^2)" -n[-1] 0,1 -t2[-1] $1,$2 -shift[-1] 50%,50%,50%,0,2
    -fft[-2] -*[-3] [-1] -*[-2,-1] -ifft[-2,-1] -rm[-1]
  -mv[-1] 0 -done -v +

#@gmic rgb2bayer : _start_pattern=0,_color=0 : Transform selected color images to RGB-Bayer sampled images.
rgb2bayer : -skip ${1=0},${2=0}
  -if $2 -e[^-1] "Transform image$? to a RGB-Bayer color grid, starting from pattern '$1'."
  -else -e[^-1] "Transform image$? to a RGB-Bayer monochrome grid, starting from pattern '$1'."
  -endif
  -v - -to_rgb -repeat @#
    -_rgb2bayer$1 -r[-1] [-2],0,2 -*[-2,-1]
    -if $2 -else -s[-1] c -+[-3--1] -endif
  -mv[-1] 0 -done -v +

_rgb2bayer0 : (1,0;0,0^0,1;1,0^0,0;0,1)
_rgb2bayer1 : (0,0;0,1^0,1;1,0^1,0;0,0)
_rgb2bayer2 : (0,0;1,0^1,0;0,1^0,1;0,0)
_rgb2bayer3 : (0,1;0,0^1,0;0,1^0,0;1,0)

#@gmic bayer2rgb : _GM_smoothness,_RB_smoothness1,_RB_smoothness2 : Transform selected RGB-Bayer sampled images to color images.
bayer2rgb : -skip ${1=1},${2=1},${3=0.5}
  -e[^-1] "Transform RGB-Bayer image$? to color images, with smoothness ($1,$2,$3)."
  -v - -channels 0 -repeat @#

    # Expand image size to avoid problems with borders.
    -expand_x[-1] {"2 + 4*$1"},0 -expand_y[-1] {"2 + 4*$1"},0

    # Compute green-magenta chromaticity.
    (-1,1;1,-1) -r[-1] [-2],[-2],1,1,0,2
    --*[-2] [-1]

    (0.25,0.5,0.25) -convolve[-2] [-1] -transpose[-1] -convolve[-2] [-1] -rm[-1]
    -blur[-1] $1

    -*[-2] [-1]
    --[-3,-2]

    # Compute red-blue chromaticity.
    (1,-1) -r[-1] [-2],[-2],1,1,0,2  # Horizontal estimate
    -*[-1] [-3]
    (0.25,0.5,0.25) -convolve[-2] [-1] -transpose[-1] -convolve[-2] [-1] -rm[-1]
    -blur_y[-1] $2 -blur_x[-1] $3

    (1;-1) -r[-1] [-2],[-2],1,1,0,2  # Vertical estimate
    -*[-1] [-4]
    (0.25,0.5,0.25) -convolve[-2] [-1] -transpose[-1] -convolve[-2] [-1] -rm[-1]
    -blur_x[-1] $2 -blur_y[-1] $3

    -+[-2,-1] -/[-1] 2

    # Luminance reconstruction.
    (2,0;0,-2) -r[-1] [-2],[-2],1,1,0,2
    -*[-1] [-2]
    --[-4,-1]

    # RGB reconstruction.
    -a[-3--1] c
    -mix_rgb[-1] 1,-1,2,1,1,0,1,-1,-2

    # Shrink to original image size.
    -shrink_x[-1] {"2 + 4*$1"},0 -shrink_y[-1] {"2 + 4*$1"},0
    -cut[-1] 0,255

  -mv[-1] 0 -done -v +

#@gmic pde_flow : _nb_iter>=0,_dt,_velocity_command,_sequence_flag={0|1} : Apply iterations of a generic PDE flow on selected images.
pde_flow : -skip ${1=10},${2=30},${3=laplacian},${4=0}
  -e[^-1] "Apply $1 iterations of the velocity flow '$3' on image$?, with time step $2."
  -v - -repeat @# -l[-1] -repeat $1
    --$3[-1] (@{-1,m},@{-1,M}) -abs[-1] -+[-1] 0.01 -/[-2] @{-1,M} -rm[-1] -*[-1] $2
    -if $4 -+[-1] [-2] -else -+[-2,-1] -endif
  -done -if $4 -rm[0] -endif -a x -endl
  -mv[-1] 0 -done -if $4 -s x,$1 -endif -v +

#@gmic heat_flow : _nb_iter>=0,_dt,_sequence_flag={0|1} : Apply iterations of the heat flow on selected images.
heat_flow : -skip ${1=10},${2=30},${3=0}
  -e[^-1] "Apply $1 iterations of the heat flow on image$?, with time step $2."
  -v - -pde_flow $1,$2,laplacian,$3 -v +

#@gmic meancurvature_flow : _nb_iter>=0,_dt,_sequence_flag={0|1} : Apply iterations of the mean curvature flow on selected images.
meancurvature_flow : -skip ${1=5},${2=30},${3=0}
  -e[^-1] "Apply $1 iterations of the mean curvature flow on image$?, with time step $2."
  -v - -pde_flow $1,$2,meancurvature_flow_velocity,$3 -v +
meancurvature_flow_velocity :
  --gradient_derivative2[-1] -laplacian[-2] --[-2,-1]

#@gmic tv_flow : _nb_iter>=0,_dt,_sequence_flag={0|1} : Apply iterations of the total variation flow on selected images.
tv_flow : -skip ${1=5},${2=30},${3=0}
  -e[^-1] "Apply $1 iterations of the total variation flow on image$?, with time step $2."
  -v - -pde_flow $1,$2,tv_flow_velocity,$3 -v +

tv_flow_velocity :
  --gradient[-1] xyz -sqr[-3--1] -+[-3--1] -sqrt[-1] -+[-1] 0.1 -meancurvature_flow_velocity[-2] -/[-2,-1]

#@gmic inpaint_flow : _nb_iter1>=0,_nb_iter2>=0,_dt>=0,_alpha,_sigma : Apply iteration of the inpainting flow on selected images.
inpaint_flow : -skip ${1=4},${2=15},${3=15},${4=1},${5=3}
  -e[^-1] "Apply $1 iteration of the inpainting flow on image$?."
  -v - -norm[0] -quantize[0] 2 -n[0] 0,1 -repeat @# -if @{>,-1} -l[0,@{>,-1}]
  -r[0] [1] -inpaint[1] [0]
  -repeat $1
     --edgetensors[1] 0,1,$4,$5,0 -*[2] [0] -smooth[1] [2],$2,$3,0 -rm[2]
  -done
  -endl -endif -done -v +

#@gmic remove_hotpixels : _mask_size>0, _threshold[%]>0 : Remove hot pixels in selected images.
remove_hotpixels : -check "isint(${1=3}) && $1>0" -skip ${2=10%}
  -e[^-1] "Remove hot pixels in image$?, with mask size $1 and threshold $2."
  -v - -repeat @#
    --median[-1] $1 ---[-1,-2] -abs[-1] -t[-1] $2
    -*[-2] [-1]
    -*[-1] -1 -+[-1] 1
    -*[-3,-1] -+[-2,-1]
  -mv[-1] 0 -done -v +

#@gmic lic : _amplitude>0,_channels>0 : Generate LIC representation of vector field.
lic : -skip ${1=30},${2=1}
  -e[^-1] "Generate LIC representation of 2D vector field$?, with amplitude $1 and $2 channel(s)."
  -v - -repeat @#
     -channels[-1] 0,1 -/[-1] {max(abs(@{-1,m}),abs(@{-1,M}))} -vector2tensor[-1]
     100%,100%,100%,$2 -rand[-1] 0,255 -smooth[-1] [-2],$1 -rm[-2]
     -equalize[-1] 256
  -mv[-1] 0 -done -v +

#--------------------------------------------------
#
# Value manipulation
#
#--------------------------------------------------

#@gmic complex2polar : : Compute complex to polar transforms of selected images.
complex2polar :
  -e[^-1] "Compute complex to polar transforms of image$?."
  -v - -repeat {@#/2}
    -r[-1] [-2],3 --atan2[-1] [-2] -sqr[-3,-2] -+[-3,-2] -sqrt[-2]
  -mv[-2,-1] 0 -done -v +

#@gmic polar2complex : : Compute polar to complex transforms of selected images.
polar2complex :
  -e[^-1] "Compute polar to complex transforms of image$?."
  -v - -repeat {@#/2}
    -r[-1] [-2],3 --sin[-1] -cos[-2] -*[-1] [-3] -*[-3,-2]
  -mv[-2,-1] 0 -done -v +

#@gmic transfer_histogram : : Transfer histogram of the last selected image to the other ones.
transfer_histogram :
  -e[^-1] "Transfer histogram of the last selected image to image$?."
  -v - -to_rgb -c 0,255 -equalize[0--2] 256 --histogram_cumul[-1] 256 -/[-1] @{-3,#} -*[-1] 255
  -repeat @#-2
    -s[-3] c -index[-5--3] [-1] -a[-5--3] c
  -mv[-3] 0 -done -rm[-1] -v +

#@gmic normalize_sum : : Normalize selected images with a unitary sum.
normalize_sum :
  -e[^-1] "Normalize image$? with a unitary sum."
  -v - -repeat @#
    (@{-1,+}) -if {@-1>0} -/[-2] @-1 -endif -rm[-1]
  -mv[-1] 0 -done -v +

#@gmic apply_gamma : gamma : Apply gamma correction to selected images.
apply_gamma : -skip ${1=1.2}
  -e[^-1] "Apply Gamma-correction to image$?, with gamma $1."
  -if {$1==1} -return -endif
  -v - -repeat @#
    (@{-1,m},@{-1,M}) -n[-2] 0,1 -pow[-2] {1/$1} -n[-2] @-1 -rm[-1]
  -mv[-1] 0 -done -v +

#@gmic negative : : Compute negative of selected images.
negative :
  -e[^-1] "Compute negative of image$?."
  -v - -repeat @#
    --[-1] @{-1,M} -*[-1] -1
  -mv[-1] 0 -done -v +

#@gmic tones : N>0 : Get N tones masks from selected images.
tones : -skip ${1=3}
  -e[^-1] "Get $1 tones masks from image$?."
  -v - -norm -repeat @#
    -repeat $1 --t2[{-1-@{>,-1}}] {@{>,-1}*100.01/$1}%,{(@{>,-1}+1)*100.01/$1}% -done -rm[-{$1+1}]
  -mv[-$1--1] 0 -done -v +

#@gmic threshold2 : _min,_max : Threshold selected images between the two given values (eq. to '-t2').
threshold2 : -skip ${1=0%},${2=100%}
  -e[^-1] "Hard-threshold image$? between values $1 and $2."
  -v -
  -repeat @#
    --t[-1] $1 -t[-2] $2 -xor[-2,-1]
  -mv[-1] 0 -done -v +

#@gmic t2 : eq. to '-threshold2'. :
t2 : -threshold2 $*

#-----------------------------
#
# Image resizing
#
#-----------------------------

#@gmic resize2dx : width>0,_interpolation_type={0,1,2,3,4,5} : Resize selected images along the X-axis, preserving 2D ratio (eq. to '-r2dx').
resize2dx : -check "$1>0 && ${2=2}>=0 && $2<=5"
  -e[^-1] "Resize 2D image$? to $1 pixels along the X-axis, preserving 2D ratio."
  -v - -repeat @#
    (@{-1,h}) -*[-1] $1 -/[-1] @{-2,w} -c[-1] 1,100%
    -r[-2] $1,@-1,[-2],[-2],$2 -rm[-1]
  -mv[-1] 0 -done -v +

r2dx :
  -resize2dx $*

#@gmic resize3dx : width>0,_interpolation_type={0,1,2,3,4,5} : Resize selected images along the X-axis, preserving 3D ratio (eq. to '-r3dx').
resize3dx : -check "$1>0 && ${2=2}>=0 && $2<=5"
  -e[^-1] "Resize 3D image$? to $1 pixels along the X-axis, preserving 3D ratio."
  -v - -repeat @#
    (@{-1,h},@{-1,d}) -*[-1] $1 -/[-1] @{-2,w} -c[-1] 1,100%
    -r[-2] $1,@-1,[-2],$2 -rm[-1]
  -mv[-1] 0 -done -v +

r3dx :
  -resize3dx $*

#@gmic resize2dy : height>0,_interpolation_type={0,1,2,3,4,5} : Resize selected images along the Y-axis, preserving 2D ratio (eq. to '-r2dy').
resize2dy : -check "$1>0 && ${2=2}>=0 && $2<=5"
  -e[^-1] "Resize 2D image$? to $1 pixels along the Y-axis, preserving 2D ratio."
  -v - -repeat @#
    (@{-1,w}) -*[-1] $1 -/[-1] @{-2,h} -c[-1] 1,100%
    -r[-2] @-1,$1,[-2],[-2],$2 -rm[-1]
  -mv[-1] 0 -done -v +

r2dy :
  -resize2dy $*

#@gmic resize3dy : height>0,_interpolation_type={0,1,2,3,4,5} : Resize selected images along the Y-axis, preserving 3D ratio (eq. to '-r3dy').
resize3dy : -check "$1>0 && ${2=2}>=0 && $2<=5"
  -e[^-1] "Resize 3D image$? to $1 pixels along the Y-axis, preserving 3D ratio."
  -v - -repeat @#
    (@{-1,w},@{-1,h}) -*[-1] $1 -/[-1] @{-2,h} -c[-1] 1,100%
    -r[-2] @{-1,0},$1,@{-1,1},[-2],$2 -rm[-1]
  -mv[-1] 0 -done -v +

r3dy :
  -resize3dy $*

#@gmic resize3dz : depth>0,_interpolation_type={0,1,2,3,4,5} : Resize selected images along the Z-axis, preserving 3D ratio (eq. to '-r3dz').
resize3dz : -check "$1>0 && ${2=2}>=0 && $2<=5"
  -e[^-1] "Resize 3D image$? to $1 pixels along the Z-axis, preserving 3D ratio."
  -v - -repeat @#
    (@{-1,w},@{-1,h}) -*[-1] $1 -/[-1] @{-2,d} -c[-1] 1,100%
    -r[-2] @-1,$1,[-2],$2 -rm[-1]
  -mv[-1] 0 -done -v +

r3dz :
  -resize3dz $*

#@gmic upscale_smart : width,height,_depth,smoothness>=0,_anisotropy=[0,1],sharpening>=0 : Upscale selected images with an edge-preserving algorithm.
upscale_smart : -skip ${2=100%},${3=100%} -check "${4=2}>=0 && ${5=0.4}>=0 && $5<=1 && ${6=10}>=0"
  -e[^-1] "Upscale image$? to $1x$2x$3, with smoothness $4, anisotropy $5 and sharpening $6."
  -v - -repeat @#
    -p @{-1,w} -p @{-1,h}
    --edgetensors 0,$5,1.2,1.2
    -r[-2,-1] $1,$2,$3,100%,5
    -if {@{-1,w}<~-2" || "@{-1,h}<~-1}  # Test for downscaling
      -rm[-1] -f[-1] 0
    -else
      -smooth[-2] [-1],$4 -rm[-1]
      -apply_channels "-sharpen[-1] $6,1,10",3,0
    -endif
    -pp[-2,-1]
  -mv[-1] 0 -done -v +

#@gmic expand_x : size_x>=0,_borders={0,1,2} : Expand selected images along the X-axis.
expand_x : -check "$1>=0 && ${2=1}>=0 && $2<=2"
  -e[^-1] "Expand image$? along the X-axis with size $1 and border conditions $2."
  -v - -repeat @#
    -if {$2==0} $1,100%,100%,100% -i[-3] [-1] -a[-3--1] x
    -elif {$2==1} --columns[-1] 0 --columns[-2] 100% -r[-2,-1] $1 -mv[-2] -3 -a[-3--1] x
    -else (@{-1,w}) -+[-1] $1 -+[-1] $1 -r[-2] @-1,[-2],[-2],[-2],0,2,0.5,0.5 -rm[-1]
    -endif
  -mv[-1] 0 -done -v +

#@gmic expand_y : size_y>=0,borders={0,1,2} : Expand selected images along the Y-axis.
expand_y : -check "$1>=0 && ${2=1}>=0 && $2<=2"
  -e[^-1] "Expand image$? along the Y-axis with size $1 and border conditions $2."
  -v - -repeat @#
    -if {$2==0} 100%,$1,100%,100% -i[-3] [-1] -a[-3--1] y
    -elif {$2==1} --lines[-1] 0 --lines[-2] 100% -r[-2,-1] 100%,$1 -mv[-2] -3 -a[-3--1] y
    -else (@{-1,h}) -+[-1] $1 -+[-1] $1 -r[-2] [-2],@-1,[-2],[-2],0,2,0.5,0.5 -rm[-1]
    -endif
  -mv[-1] 0 -done -v +

#@gmic expand_z : size_z>=0,borders={0,1,2} : Expand selected images along the Z-axis.
expand_z : -check "$1>=0 && ${2=1}>=0 && $2<=2"
  -e[^-1] "Expand image$? along the Z-axis with size $1 and border conditions $2."
  -v - -repeat @#
    -if {$2==0} 100%,100%,$1,100% -i[-3] [-1] -a[-3--1] z
    -elif {$2==1} --slices[-1] 0 --slices[-2] 100% -r[-2,-1] 100%,100%,$1 -mv[-2] -3 -a[-3--1] z
    -else (@{-1,d}) -+[-1] $1 -+[-1] $1 -r[-2] [-2],[-2],@-1,[-2],0,2,0.5,0.5 -rm[-1]
    -endif
  -mv[-1] 0 -done -v +

#@gmic expand_xy : size>=0,borders={0,1,2} : Expand selected images along the XY-axes.
expand_xy : -check "$1>=0 && ${2=1}>=0 && $2<=2"
  -e[^-1] "Expand image$? along the XY-axes with size $1 and border conditions $2."
  -v - -expand_x $1,$2 -expand_y $1,$2 -v +

#@gmic expand_xyz : size>=0,borders={0,1,2} : Expand selected images along the XYZ-axes.
expand_xyz : -check "$1>=0 && ${2=1}>=0 && $2<=2"
  -e[^-1] "Expand image$? along the XYZ-axes with size $1 and border conditions $2."
  -v - -expand_x $1,$2 -expand_y $1,$2 -expand_z $1,$2 -v +

#@gmic shrink_x : size_x>=0 : Shrink selected images along the X-axis.
shrink_x : -check "$1>=0"
  -e[^-1] "Shrink image$? along the X-axis with size $1."
  -v - -repeat @#
    (@{-1,w}) --[-1] $1 --[-1] 1 -crop[-2] $1,@-1 -rm[-1]
  -mv[-1] 0 -done -v +

#@gmic shrink_y : size_y>=0 : Shrink selected images along the Y-axis.
shrink_y : -check "$1>=0"
  -e[^-1] "Shrink image$? along the Y-axis with size $1."
  -v - -repeat @#
    (@{-1,h}) --[-1] $1 --[-1] 1 -crop[-2] 0,$1,100%,@-1 -rm[-1]
  -mv[-1] 0 -done -v +

#@gmic shrink_z : size_z>=0 : Shrink selected images along the Z-axis.
shrink_z : -check "$1>=0"
  -e[^-1] "Shrink image$? along the Z-axis with size $1."
  -v - -repeat @#
    (@{-1,d}) --[-1] $1 --[-1] 1 -crop[-2] 0,0,$1,100%,100%,@-1 -rm[-1]
  -mv[-1] 0 -done -v +

#@gmic shrink_xy : size>=0 : Shrink selected images along the XY-axes.
shrink_xy : -check "$1>=0"
  -e[^-1] "Shrink image$? along the XY-axes with size $1."
  -v - -shrink_x $1 -shrink_y $1 -v +

#@gmic elevate : _depth,_is_plain,_is_colored : Elevate selected 2D images into 3D volumes.
elevate : -check "${1=64}>0" -skip ${2=1},${3=1}
  -e[^-1] "Elevate 2D image$? into $1-slices volume(s)."
  -v - -r 100%,100%,1,100%
  -repeat @# -l[-1]
  --norm[0] -i 100%,100%,$1,{if($3,@{0,s},1)}
    -p @{-2,m} -p {@{-2,M}-~-1}
    -repeat $1
      -if $2
        --t[1] {~-2+~-1*(@{>,-1}+1)/$1}
      -else
        --t2[1] {~-2+~-1*@{>,-1}/$1},{~-2+~-1*(@{>,-1}+1)/$1}
      -endif
      -r[-1] 100%,100%,1,[-2] -if $3 -*[-1] [0] -endif
      -image[-2] [-1],0,0,@{>,-1} -rm[-1]
    -done
    -pp[-2,-1] -rm[0,1]
  -endl -mv[-1] 0 -done -v +

#--------------------------------------------------
#
# Arrays and frames
#
#--------------------------------------------------

#@gmic array : _M>0,_N>0,_expand_type={0,1,2} : Create MxN array from selected images.
array : -skip ${1=3},${2=$1},${3=0}
  -e[^-1] "Create $1x$2 array from image$?, with expand type $3."
  -v - -repeat @#
    -array_expand$3 $1,$2 [-1]x$1 -rm[-1] -a[-$1--1] x [-1]x$2 -rm[-1] -a[-$2--1] y
  -mv[-1] 0 -done -v +
array_expand0 :
  (100) ($1,$2) -/[-2] @{-1,M} -rm[-1] -r[-2] @-1%,@-1%,1,100%,2 -rm[-1]
array_expand1 :
  (100) ($1,$2) -/[-2] @{-1,m} -rm[-1] -r[-2] @-1%,@-1%,1,100%,2 -rm[-1]
array_expand2 :
  -skip $*

#@gmic array_fade : _M>0,_N>0,0<=_fade_start<=100,0<=_fade_end<=100,_expand_type={0,1,2} : Create MxN array from selected images.
array_fade : -skip ${1=3},${2=$1},${3=60},${4=90},${5=1}
  -e[^-1] "Create $1x$2 array of ($3%,$4%) faded tiles from image$?, with expand type $5."
  -v - -repeat @#
    --shift[-1] 50%,50%,1,1,2 -mv[-1] -2 -fade_diamond[-2,-1] $3,$4 -array[-1] $1,$2,$5
  -mv[-1] 0 -done -v +

#@gmic array_mirror : _N>=0,_dir={0,1,2},_expand_type={0|1} : Create 2^Nx2^N array from selected images.
array_mirror : -skip ${1=2},${2=2},${3=0}
  -e[^-1] "Create a 2^$1x2^$1 mirrored-array from image$?, with expand type $2."
  -v - -repeat $1
    -if {$3==0} -r 50%,50%,100%,100%,2 -endif
    -repeat @#
      -if {$2==0} --mirror[-1] x -a[-2,-1] x
      -elif {$2==1} --mirror[-1] y -a[-2,-1] y
      -else --mirror[-1] x -a[-2,-1] x --mirror[-1] y -a[-2,-1] y
      -endif
    -mv[-1] 0 -done
  -done -v +

#@gmic array_random : _Ms>0,_Ns>0,_Md>0,_Nd>0 : Create MdxNd array of tiles from selected MsxNs source arrays.
array_random : -skip ${1=5},${2=$1},${3=$1},${4=$2}
  -e[^-1] "Create $3x$4 array of tiles from $1x$2 array$?."
  -v - -repeat @#
    -l[-1] -split_tiles $1,$2
    -repeat $3 -repeat $4 [{?(0,$1*$2)>>0}] -done -done
    -rm[0-{$1*$2-1}] -append_tiles $3,$4
  -endl -mv[-1] 0 -done -v +

#@gmic array_pattern : _M>0,_N>0,_density>=0,_angle>=0,_zoom>=0,_opacity,_expand_type={0,1,2} : Create random MxN array from selected images.
array_pattern : -skip ${1=10},${2=10},${3=80},${4=180},${5=30},${6=1},${7=0}
  -e[^-1] "Create $1x$2 pattern array from image$?, with density $3, angle $4, zoom $5, opacity $6 and expand type $7."
  -v - -repeat @#
    -array_expand$7 $1,$2 -set[-1] 0,0,0,0,3
    --crop[-1] 0,0,0,0,0,0,0,100% ($1,$2) (@{-3,w},@{-3,h}) -*[-2,-1] -r[-2] @-1,1,100% -rm[-1]
    $1,$2,1,1,-1 -noise[-1] $3,2 -t[-1] 0 -unroll[-1] y
    -repeat $1 -repeat $2
      -if @{-1,0}
        ({?(-$5,$5)}) -+[-1] 100 --r[-4] @-1%,@-1%,1,100%,3 -rm[-2] --f[-1] 1
        (@{>,-2--1}) (@{-6,w},@{-6,h}) -*[-2,-1]
        ({?(-$4,$4)}) -rotate[-4] @-1,1,2 -rotate[-3] @-1,0,0 -rm[-1]
        -image[-5] [-3],@{-1},0,0,$6,[-2] -rm[-3--1]
      -endif
    -shift[-1] 0,-1 -done -done -rm[-3,-1]
  -mv[-1] 0 -done -v +

#@gmic taquin : _M>0,_N>0 : Create MxN taquin puzzle from selected images.
taquin : -skip ${1=4},${2=$1}
 -e[^-1] "Create $1x$2 taquin puzzle from image $?."
 -v - -repeat @# -l[-1]
   -split_tiles $1,$2,1 -repeat {$1*$2} -mv[@{>,-1}] {?(0,@#)} -done -append_tiles $1,$2
 -endl -mv[-1] 0 -done -v +

#@gmic grid : _M>0,_N>0 : Create MxN image grid from selected images.
grid : -skip ${1=10},${2=$1}
  -e[^-1] "Create $1x$2 image grid from image$?."
  -v - -repeat @#
    (@{-1,w},@{-1,h}) ($1,$2) -/[-2,-1] -r[-2] @-1,[-2],[-2],2 -rm[-1]
    (@{-1,w},@{-1,h}) ($1,$2) -*[-2,-1] -r[-2] @-1,[-2],[-2],2 -rm[-1]
    $1,$2,1,[-1],1 -shift[-1] 1,1 -r[-1] [-2],0,2 -*[-2,-1]
  -mv[-1] 0 -done -v +

#@gmic frame : _size_x>=0,_size_y>=0,_R,_G,_B,_A : Insert RGBA-colored frame in selected images.
frame : -skip ${1=20},${2=$1},${3=255},${4=$3},${5=$4},${6=255}
  -e[^-1] "Insert $1x$2 frame with RGBA color ($3,$4,$5,$6) in image$?."
  -v - -to_rgba -repeat @#
    ($3^$4^$5^$6) -r[-1] $1,[-2],[-2],[-2],1 -i[-3] [-1] -a[-3--1] x
    ($3^$4^$5^$6) -r[-1] [-2],$2,[-2],[-2],1 -i[-3] [-1] -a[-3--1] y
  -mv[-1] 0 -done -v +

#@gmic frame_fuzzy : _size_x>=0,_size_y>=0,_fuzzyness>=0,_smoothness>=0,_R,_G,_B,_A : Draw RGBA-colored fuzzy frame in selected images.
frame_fuzzy : -skip ${1=20},${2=$1},${3=5},${4=1},${5=255},${6=$5},${7=$6},${8=255}
  -e[^-1] "Draw $1x$2 fuzzy frame on image$?, with fuzzyness $3, smoothness $4 and RGBA color ($5,$6,$7,$8)."
  -v - -to_rgba -repeat @#
    -i[0] ($1;$2) -*[0] 2 ($5^$6^$7^$8) -r[-1] [-2] 100%,100%
    -polygon[-1] 4,0,0,100%,0,100%,@{0,1},0,@{0,1},1,1
    -polygon[-1] 4,0,0,@{0,0},0,@{0,0},100%,0,100%,1,1
    -rm[0] -shift[-1] -$1,-$2,0,0,2 -spread[-1] $3 -blur[-1] $4 -_fade 50,80
  -mv[-1] 0 -done -v +

#@gmic frame_round : _sharpness>0,_size>=0,_smoothness,_R,_G,_B,_A : Draw RGBA-colored round frame in selected images.
frame_round : -skip ${1=3},${2=10},${3=0},${4=255},${5=$4},${6=$5},${7=255}
  -e[^-1] "Draw round frame on image$?, with sharpness $1, size $2, smoothness $3 and RGBA color ($4,$5,$6,$7)."
  -v - -to_rgba -repeat @#
    100%,100%,1,1,"-(abs(x/w-0.5)^$1 + abs(y/h-0.5)^$1)^(1/$1)" -t[-1] $2%
    -blur[-1] $3 -r[-1] [-2] -*[-2] [-1] -channels[-1] 0 -*[-1] -1 -+[-1] 1
    --*[-1] $5 --*[-2] $6 --*[-3] $7 -*[-4] $4 -a[-4--1] c -+[-2,-1]
  -mv[-1] 0 -done -v +

#@gmic rotate_tiles : _angle,_M>0,N>0 : Apply MxN tiled-rotation effect on selected images.
rotate_tiles : -skip ${1=5},${2=8},${3=$2}
  -e[^-1] "Apply $2x$3 tiled-rotation effect on image$?, with angle $1."
  -v - -split_tiles $2,$3,1 -rotate $1 -append_tiles $2,$3 -v +

#@gmic shift_tiles : _M>0,_N>0,_amplitude : Apply MxN tiled-shift effect on selected images.
shift_tiles : -skip ${1=8},${2=8},${3=20}
  -e[^-1] "Apply $1x$2 tiled-shift effect on image$?, with amplitude $3."
  -v - -repeat @#
    $1,$2,1,2 -noise[-1] $3 -r[-1] [-2],[-2],1,2 -warp[-2] [-1],1,1,0 -rm[-1]
  -mv[-1] 0 -done -v +

#@gmic linearize_tiles : _M>0,_N>0 : Linearize MxN tiles on selected images.
linearize_tiles : -check "${1=10}>0 && ${2=$1}>0"
  -e[^-1] "Linearize $1x$2 tiles on image$?."
  -v -
  -repeat @# -l[-1]
    -p @{-1,s} -split_tiles $1,$2 -s c # Split as tiles for all channels.
    -repeat @#
      -p @{-1,w},@{-1,h}
      --f[-1] x --f[-1] y --f[-1] 1 -unroll[-4--1] y -a[-3--1] x
      -solve[-2] [-1] -rm[-1]
      -i ~-1,1,1,@{-1,0}"*x + "@{-1,1}"*y + "@{-1,2} -rm[-2]
      -pp[-1]
    -mv[-1] 0 -done
    -repeat {@#/~-1} -a[-~-1--1] c -mv[-1] 0 -done -append_tiles $1,$2 -pp[-1]
  -endl -mv[-1] 0 -done -v +

#@gmic quadratize_tiles : _M>0,_N>0 : Quadratize MxN tiles on selected images.
quadratize_tiles : -check "${1=10}>0 && ${2=$1}>0"
  -e[^-1] "Quadratize $1x$2 tiles on image$?."
  -v -
  -repeat @# -l[-1]
    -p @{-1,s} -split_tiles $1,$2 -s c # Split as tiles for all channels.
    -repeat @#
      -p @{-1,w},@{-1,h}
      --f[-1] x^2 --f[-1] y^2 --f[-1] x*y --f[-1] x --f[-1] y --f[-1] 1 -unroll[-7--1] y -a[-6--1] x
      -solve[-2] [-1] -rm[-1]
      -i ~-1,1,1,@{-1,0}"*x^2 + "@{-1,1}"*y^2 + "@{-1,2}"*x*y +"@{-1,3}"*x + "@{-1,4}"*y + "@{-1,5} -rm[-2]
      -pp[-1]
    -mv[-1] 0 -done
    -repeat {@#/~-1} -a[-~-1--1] c -mv[-1] 0 -done -append_tiles $1,$2 -pp[-1]
  -endl -mv[-1] 0 -done -v +

#--------------------------------------------------
#
# Artistic effects
#
#--------------------------------------------------

#@gmic polaroid : _size1>=0,_size2>=0 : Create polaroid effect in selected images.
polaroid : -skip ${1=10},${2=20}
  -e[^-1] "Create polaroid effect in image$?, with borders sizes $1 and $2."
  -v - -- 255 -r {100+$1}%,{100+$1}%,1,100%,0,0,0.5,0.5 -r 100%,{100+$2}%,1,100%,0,0,0 -+ 255 -v +

#@gmic drop_shadow : _offset_x[%],_offset_y[%],_smoothness[%] : Drop shadow behind selected images.
drop_shadow : -skip ${1=20},${2=$1},${3=5}
  -e[^-1] "Drop shadow behind image$?, with offsets ($1,$2) and smoothness $3."
  -v - -to_rgba -repeat @#
    -r[-1] 150%,150%,1,100%,0,0,0.5,0.5 -s[-1] c --blur[-1] $3 -shift[-1] $1,$2 -or[-2,-1] -a[-4--1] c -autocrop 0,0,0,0
  -mv[-1] 0 -done -v +

#@gmic tetris : _scale>0 : Apply tetris effect on selected images.
tetris : -skip ${1=10}
  -e[^-1] "Apply tetris effect on image$?, with scale $1."
  -v - -repeat @#
    --r[-1] $1%,$1%,$1%,3,2 -n[-1] 0,255 -quantize[-1] 10
    -r[-1] [-2] -rm[-2] -blur[-1] 2 -sharpen[-1] 300,1
  -mv[-1] 0 -done -v +

#@gmic mosaic : _density>=0,_amplitude,_relief={0|1} : Add random mosaic pattern to selected images.
mosaic : -skip ${1=0.2},${2=40},${3=0}
  -e[^-1] "Add random mosaic pattern to image$?, with density $1."
  -v - -repeat @#
    (@{-1,m},@{-1,M}) [-2],[-2],1,1 -noise[-1] $1,2 -distance[-1] 1 -sharpen[-1] 10000
    -if $3 -gradient[-1] xy -+[-2,-1] -n[-1] -1,1 -else -n[-1] 0,1 -endif
    -*[-1] $2 -+[-3,-1] -c[-2] @-1 -rm[-1]
  -mv[-1] 0 -done -v +

#@gmic mosaic2 : _density>=0,_relief={ 0 | 1 }
mosaic2 : -skip ${1=0.3},${2=1}
  -repeat @#
    [-1],[-1] -noise[-1] $1,2 --distance[-1] 1 -*[-1] -1 -*[-3,-2] -r[-1] [-2]
    -watershed[-2] [-1] -rm[-1]

    --luminance[-1] -gradient[-1] xy,1 -sqr[-2,-1] -+[-2,-1] -t[-1] 0.1 -*[-1] -1 -+[-1] 1
    -*[-2,-1]

  -mv[-1] 0 -done

#@gmic puzzle : _scale>=0 : Apply puzzle effect on selected images.
puzzle : -skip ${1=5}
  -e[^-1] "Apply puzzle effect on image$?, with scale $1%."
  -v - -repeat @#
    [-1] -r[-1] $1%,$1%,100%,100%,2 -noise[-1] 0.1 -r[-1] [-2] -rm[-2]
    [-1]x2 -shift[-1] -1,-1 --[-2,-1] -norm[-1] -t[-1] 0.01 -*[-1] -1
    -+[-1] 1 -r[-1] [-2] -*[-1,-2] 10%,10%,10%,2 -noise[-1] 5,1
    -r[-1] [-2],[-2],1,2,5 -warp[-2] [-1],1,1,1 -rm[-1]
  -mv[-1] 0 -done -v +

#@gmic sponge : _size>0 : Apply sponge effect on selected images.
sponge : -skip ${1=13}
  -e[^-1] "Apply sponge filter on image$?, with brush size $1."
  -v - -repeat @#
    100%,100%,1,1 -noise[-1] 20,2 -r[-1] [-2] -n[-1] 0,1 -*[-1,-2]
    -_circle $1 -dilate[-2] [-1] -rm[-1]
  -mv[-1] 0 -done -v +
_circle :
  -i 1 -+[-1] 1 -r[-1] $1,$1,1,1,0,0,0.5,0.5 -distance[-1] 1 -n[-1] 0,1 -sqrt[-1] -c[-1] 0.85,0.86 -*[-1] -1 -n[-1] 0,1

#@gmic hearts : _density>=0 : Apply heart effect on selected images.
hearts : -skip ${1=10}
  -e[^-1] "Apply heart filter on image$?, with density $1."
  -v - -repeat @#
    100%,100%,1 -noise[-1] $1,2 -r[-1] [-2] -n[-1] 0,1 -*[-1,-2] -_heart9x7
    -mirror[-1] y -dilate[-2] [-1] -rm[-1]
  -mv[-1] 0 -done -v +

_heart9x7 :
  (0,1,1,0,0,0,1,1,0;1,1,1,1,0,1,1,1,1;1,1,1,1,1,1,1,1,1;0,1,1,1,1,1,1,1,0;0,0,1,1,1,1,1,0,0;0,0,0,1,1,1,0,0,0;0,0,0,0,1,0,0,0,0)

#@gmic color_ellipses : _count>0,_radius>=0,_opacity>=0 : Add random color ellipses to selected images.
color_ellipses : -skip ${1=1400},${2=5},${3=0.1}
  -e[^-1] "Add $1 random color ellipses to image$?, with maximum radius $2 and opacity $1."
  -v - -repeat @#
    -repeat $1 -ellipse[-1] {?(0,100)}%,{?(0,100)}%,{?(0,$2)}%,{?(0,$2)}%,{?(0,360)},$3,{?(60,255)},{?(60,255)},{?(60,255)} -done
  -mv[-1] 0 -done -v +

#@gmic whirls : _texture>=0,_smoothness>=0,_darkness>=0,_lightness>=0 : Add random whirl texture to selected images.
whirls : -skip ${1=3},${2=6},${3=0.5},${4=1.8}
  -e[^-1] "Add random whirl texture to image$?, with texture $1, smoothness $2, darkness $3 and lightness $4."
  -v - -repeat @#
    100%,100% -noise[-1] 0.3,2 -repeat $1 -blur[-1] $2 -gradient_norm[-1] -pow[-1] 0.2 -done
    -n[-1] $3,$4 -r[-1] [-2] -*[-2,-1] -c[-1] 0,255
  -mv[-1] 0 -done -v +

#@gmic cartoon : _smoothness,_sharpening,_threshold>=0,_thickness>=0,_color>=0,quantization>0 : Apply cartoon effect on selected images.
cartoon : -skip ${1=2},${2=200},${3=15},${4=0.25},${5=1.5},${6=8}
  -e[^-1] "Apply cartoon effect on image$?, with smoothness $1, sharpening $2, threshold $3, thickness $4, color $5 and quantization $6."
  -v - -to_rgb -blur $1 -sharpen $2,1 -c 0,255 -n 0,255 -repeat @#
    --edges[-1] $3 -blur[-1] $4 -t[-1] 0.9
    -rgb2lab[-2] -s[-2] c -*[-3,-2] $5 -a[-4--2] c -lab2rgb[-2] -quantize[-2] $6 -n[-2] 0,255
    -*[-2,-1]
  -mv[-1] 0 -done -v +

#@gmic drawing : _amplitude>=0 : Apply drawing effect on selected images.
drawing : -skip ${1=200}
  -e[^-1] "Apply drawing effect on image$? with amplitude $1."
  -v - -repeat @#
    -smooth[-1] $1,0.2,1,3,3 -blur[-1] 2 -sharpen[-1] 1000 [-1]
    -r[-2] 20,20,1,3,2 -equalize[-2] 256 -index[-1] [-2],1,1 -rm[-2]
  -mv[-1] 0 -done -v +

#@gmic draw_whirl : _amplitude>=0 : Apply whirl drawing effect on selected images.
draw_whirl : -skip ${1=100}
  -e[^-1] "Apply whirl drawing effect on image$? with amplitude $1."
  -v - -repeat @#
    100%,100% -noise[-1] 70,2 -*[-1] 255 -r[-1] [-2] -and[-1,-2] -smooth[-1] $1,0,1,2,2
    -sqrt[-1] -n[-1] 0,255 -equalize[-1] 256
  -mv[-1] 0 -done -v +

#@gmic stencilbw : _edges>=0,_smoothness>=0 : Apply B&W stencil effect on selected images.
stencilbw : -skip ${1=15},${2=10}
  -e[^-1] "Apply B&W stencil effect on image$?, with edges $1 and smoothness $2."
  -v - -repeat @#
    -r[-1] 100%,100%,1,100% --edges[-1] $1 -quantize[-2] 3 -blur[-2] $2
    -sharpen[-2] 1000000 -norm[-2] -n[-2] 0,1 -*[-1,-2] -n[-1] 0,255
  -mv[-1] 0 -done -v +

#@gmic pencilbw : _size>=0,_amplitude>=0 : Apply B&W pencil effect on selected images.
pencilbw : -skip ${1=0.3},${2=60}
  -e[^-1] "Apply B&W pencil effect on image$?, with size $1 and amplitude $2."
  -v - -repeat @#
    -p @{-1,s}
    -to_rgb[-1] -norm[-1] -blur[-1] $1 -sharpen[-1] 4000 -smooth[-1] $2,0,1 -equalize[-1] 256 -sqrt[-1] -n[-1] 0,255
    -to_colormode[-1] ~-1 -pp[-1]
  -mv[-1] 0 -done -v +

#@gmic ditheredbw : : Create dithered B&W version of selected images.
ditheredbw :
  -e[^-1] "Create dithered B&W version of image$?."
  -v - -repeat @#
    -n[-1] 0,255 -r[-1] 100%,100%,100%,3 2,1,1,3,0,255 -index[-2] [-1],1,1 -rm[-1]
  -mv[-1] 0 -done -v +

#@gmic dotsbw : : Apply B&W dots effect on selected images.
dotsbw :
  -e[^-1] "Apply B&W dots effect on image$?."
  -v - -repeat @#
    -norm[-1] --r[-1] 10%,10%,1,1,2 [-1]x4 -t[-5] 10%
    -t[-4] 30% -t[-3] 50% -t[-2] 70% -t[-1] 90%
    -r[-5--1] [-6],4 -shift[-5--1] 5,5 -rm[-6] -_circle 3 -dilate[-6] [-1]
    -rm[-1] -_circle 5 -dilate[-5] [-1] -rm[-1] -_circle 7 -dilate[-4] [-1]
    -rm[-1] -_circle 9 -dilate[-3] [-1] -rm[-1] -_circle 11 -dilate[-2] [-1]
    -rm[-1] -or[-5--1] -n[-1] 0,255 -r[-1] 100%,100%,1,3
  -mv[-1] 0 -done -v +

#@gmic warhol : _M>0,_N>0,_smoothness>=0,_color>=0 : Create MxN Andy Warhol-like artwork from selected images.
warhol : -skip ${1=3},${2=$1},${3=2},${4=20}
  -e[^-1] "Create $1x$2 Andy Warhol-like artwork from image$?."
  -v - -repeat @#
    -norm[-1] -blur[-1] $3 -array_expand0 $1,$2 -quantize[-1] 6 -n[-1] 0,5 -round[-1] 1
    -l[-1] -repeat $1 -repeat $2
      (0,1,2,3,4,5) -n[-1] 32,224 6,1,1,2,128 -noise[-1] $4,0 -c[-1] 0,255 -a[-2,-1] c -ycbcr2rgb[-1] --map[0] [-1] -rm[-2]
    -done -done -append_tiles[1--1] $1,$2 -rm[0] -endl
  -mv[-1] 0 -done -v +

#@gmic cubism : _nb_iter>=0,_bloc_size>0,_max_angle,_opacity,_smoothness>=0 : Apply cubism effect on selected images.
cubism : -skip ${1=160},${2=10},${3=75},${4=0.7},${5=0}
  -e[^-1] "Apply cubism effect on image$?, with $1 iterations, bloc size $2%, maximum angle $3, opacity $4 and smoothness $5."
  -v - -repeat @#
    -p {$2*max(@{-1,w},@{-1,h})/200}
    -repeat $1
      ({?(0,@{-1,w})},{?(0,@{-1,h})})
      --crop[-2] {@{-1,0}-~-1},{@{-1,1}-~-1},{@{-1,0}+~-1},{@{-1,1}+~-1}
      -blur[-1] $5 --f[-1] 1 -rotate[-2,-1] {?(-$3,$3)},0,0
      -image[-4] [-2],{@{-3,0}-~-1},{@{-3,1}-~-1},0,0,$4,[-1] -rm[-3--1]
    -done
    -pp[-1]
  -mv[-1] 0 -done -v +

#@gmic glow : _amplitude>=0 : Add soft glow on selected images.
glow : -skip ${1=-1}
  -e[^-1] "Add soft glow on image$?, with amplitude $1."
  -v - -repeat @#
    --blur[-1] $1 -n[-1] [-2] -compose_edges[-2,-1] 1
  -mv[-1] 0 -done -v +

#@gmic old_photo : : Apply old photo effect on selected images.
old_photo :
  -e[^-1] "Apply old photo effect on image$?."
  -v - -noise 20 -bilateral 30,60 -blur 2 -sharpen 100 -frame_fuzzy 20,20,6,3 -damp_patch 0.75 -n 0,255 -sepia -v +

#------------------------------------
#
# Spatial warping
#
#------------------------------------

#@gmic euclidean2polar : _cx,_cx,_n>0,_borders={0,1,2} : Apply euclidean to polar transform on selected images.
euclidean2polar : -skip ${1=0.5},${2=0.5},${3=1},${4=1}
  -e[^-1] "Apply euclidean to polar transform on image$?."
  -v - -repeat @#
    (@{-1,w},@{-1,h}) ($1,$2) -*[-2,-1] ({"sqrt(max("@{-1,0}","@{-2,w}"-"@{-1,0}")^2 + max("@{-1,1}","@{-2,h}"-"@{-1,1}")^2)"})
    -a[-2,-1] x
    [-2],[-2],1,1,@{-1,2}"*(x/w)^$3*cos(y*2*pi/h)" -+[-1] @{-2,0}
    [-1],[-1],1,1,@{-2,2}"*(x/w)^$3*sin(y*2*pi/h)" -+[-1] @{-3,1}
    -rm[-3] -a[-2,-1] c -warp[-2] [-1],0,1,$4 -rm[-1]
  -mv[-1] 0 -done -v +

#@gmic warp_perspective : _x-angle,_y-angle,_zoom>0,_x-center,_y-center,_borders={0,1,2} : Warp selected images with perspective deformation.
warp_perspective : -skip ${1=1.5},${2=0},${3=1},${4=50},${5=50},${6=2}
  -e[^-1] "Apply perspective warp on image$?, with angles ($1,$2), zoom $3 and offsets ($4,$5)."
  -v - -repeat @#
    (0,100) --[-1] $4 -/[-1] 100 (0;100) --[-1] $5 -/[-1] 100 -r[-2,-1] [-3],[-3],[-3],1,3
    --*[-2] $2 --*[-2] $1 -+[-2,-1] -+[-1] $3 -/[-3] [-1] -/[-2,-1]
    -*[-2] 100 -+[-2] $4 -/[-2] 100 -*[-2] @{-3,w}
    -*[-1] 100 -+[-1] $5 -/[-1] 100 -*[-1] @{-3,h}
    -a[-2,-1] c -warp[-2] [-1],0,1,$6 -rm[-1]
  -mv[-1] 0 -done -v +

#@gmic polar2euclidean : _cx,_cy,_n>0,_borders={0,1,2} : Apply polar to euclidean transform on selected images.
polar2euclidean : -skip ${1=0.5},${2=0.5},${3=1},${4=1}
  -e[^-1] "Apply polar to euclidean transform on image$?."
  -v - -repeat @#
    (@{-1,w},@{-1,h}) ($1,$2) -*[-2,-1] ({"sqrt(max("@{-1,0}","@{-2,w}"-"@{-1,0}")^2 + max("@{-1,1}","@{-2,h}"-"@{-1,1}")^2)"})
    -a[-2,-1] x
    [-2],[-2],1,1,"w*(sqrt((x-"@{-1,0}")^2 + (y-"@{-1,1}")^2)/"@{-1,2}")^(1/$3)"
    [-1],[-1],1,1,"(atan2(y-"@{-2,1}",x-"@{-2,0}")*h/(2*pi)+h)%h"
    -rm[-3] -a[-2,-1] c -warp[-2] [-1],0,1,$4 -rm[-1]
  -mv[-1] 0 -done -v +

#@gmic water : _amplitude>=0,_smoothness>=0 : Apply water deformation on selected images.
water : -skip ${1=30},${2=1.5}
  -e[^-1] "Apply water deformation on image$?, with amplitude $1 and smoothness $2."
  -v - -repeat @#
    25%,25%,25%,1 -noise[-1] $1 -gradient[-1] xyz -+[-1,-2,-3] -blur[-1] $2 -*[-1] 2 -r[-1] [-2],[-2],1,2,3 -warp[-2] [-1],1 -rm[-1]
  -mv[-1] 0 -done -v +

#@gmic wave : _amplitude>=0,_frequency>=0,_center_x,_center_y : Apply wave deformation on selected images.
wave : -skip ${1=4},${2=0.4},${3=50},${4=50}
  -e[^-1] "Apply wave deformation on image$?, with amplitude $1, frequency $2 and center at ($3%,$4%)."
  -v - -repeat @#
    100%,100% -=[-1] 1,$3%,$4% -distance[-1] 1
    -*[-1] $2 --sin[-1] -cos[-2] -a[-2,-1] c -*[-1] $1
    -warp[-2] [-1],1 -rm[-1]
  -mv[-1] 0 -done -v +

#@gmic twirl : _amplitude,_cx,_cy,_borders={0,1,2} : Apply twirl deformation on selected images.
twirl : -skip ${1=1},${2=0.5},${3=0.5},${4=1}
  -e[^-1] "Apply twirl deformation on image$?, with amplitude $1 and center at ($2%,$3%)."
  -v - -repeat @#
    -euclidean2polar[-1] $2,$3,1,$4 100%,100%,1,1,$1*x -channels[-1] -1,0
    -warp[-2] [-1],1,1,2 -rm[-1] -polar2euclidean[-1] $2,$3,1,1
  -mv[-1] 0 -done -v +

#@gmic map_sphere : _width>0,_height>0,_radius,_dilation>0 : Map selected images on a sphere.
map_sphere : -skip ${1=512},${2=512},${3=100},${4=0.5}
   -e[^-1] "Map image$? on spheres in $1x$2 images, with radius $3 and dilation $4."
   -v -
   -p {($3*min($1,$2)/200)^2} # Compute squared radius.
   -repeat @#
     -i[-2] 100%,1,1,100%,0 -a[-2,-1] y # Add one border line to have a sphere exterior.
     ({-$1/2},{$1/2}) ({-$2/2};{$2/2}) -r[-2,-1] $1,$2,1,1,3 -atan2[-1] [-2] -rm[-2] # Compute theta angle.
     $1,$2 -=[-1] 1,50%,50% -distance[-1] 1 -sqr[-1] -/[-1] ~-1 -sqrt[-1] -cut[-1] 0,1 -asin[-1] # Compute phi angle.
     -+[-2] {pi} -*[-2] {(@{-3,w}-1)/(2*pi)} # Normalize theta to X-coordinates
     -*[-1] {2/pi} -pow[-1] $4 -*[-1] {@{-3,h}-1} -*[-1] -1 -+[-1] {@{-3,h}-1} # Normalize phi to Y-coordinates
     -a[-2,-1] c -warp[-2] [-1],0,1,1 -rm[-1] # Apply image warping
   -mv[-1] 0 -done
   -pp[-1] -v +

#@gmic flower : _amplitude,_frequency,_offset_r[%],_angle,_cx,_cy,_borders={0,1,2} : Apply flower deformation on selected images.
flower : -skip ${1=30},${2=6},${3=0},${4=0},${5=0.5},${6=0.5},${7=2}
  -e[^-1] "Apply flower deformation on image$?, with amplitude $1, frequency $2, offset $3, angle $4 and center ($1,$2)."
  -v - -repeat @#
    -euclidean2polar[-1] $5,$6,1,$7 -shift[-1] $3,0,0,0,2
    100%,100%,1,1,y -/[-1] @{-1,h} -*[-1] $2 ({$4/360}) -+[-2] @-1 -rm[-1] -*[-1] 6.2831853 -sin[-1]
    -*[-1] $1 -*[-1] @{-1,w} -/[-1] 100
    -channels[-1] 0,1 -warp[-2] [-1],1,1,$7 -rm[-1]
    -polar2euclidean[-1] $5,$6,1,1
  -mv[-1] 0 -done -v +

#@gmic zoom : _factor,_cx,_cy,_cz,_borders={0,1,2} : Apply zoom factor to selected images.
zoom : -skip ${1=2},${2=0.5},${3=0.5},${4=0.5},${5=0}
  -e[^-1] "Apply zoom effect on image$?, with factor $1 and center ($2,$3)."
  -v - -repeat @#
    -if {@{-1,d}==1} # 2D image.
       ({(@{-1,w}-1)*$2*(1-1/$1)},{(@{-1,w}-1)*($2+(1-$2)/$1)})
       ({(@{-2,h}-1)*$3*(1-1/$1)};{(@{-2,h}-1)*($3+(1-$3)/$1)})
       -r[-2--1] [-3],[-3],1,1,3 -a[-2--1] c -warp[-2] [-1],0,1,$5
    -else # 3D image.
       ({(@{-1,w}-1)*$2*(1-1/$1)},{(@{-1,w}-1)*($2+(1-$2)/$1)})
       ({(@{-2,h}-1)*$3*(1-1/$1)};{(@{-2,h}-1)*($3+(1-$3)/$1)})
       ({(@{-3,d}-1)*$4*(1-1/$1)}/{(@{-3,d}-1)*($4+(1-$4)/$1)})
       -r[-3--1] [-4],[-4],[-4],1,3 -a[-3--1] c -warp[-2] [-1],0,1,$5
    -endif
    -rm[-1]
  -mv[-1] 0 -done -v +

#@gmic deform : _amplitude>=0 : Apply random smooth deformation on selected images.
deform : -skip ${1=10}
  -e[^-1] "Apply random smooth deformation on image$?, with amplitude $1."
  -v - -repeat @#
    2%,2%,1,2 -noise[-1] $1 -r[-1] [-2],[-2],1,2,5 -warp[-2] [-1],1,1,1 -rm[-1]
  -mv[-1] 0 -done -v +

#@gmic fish_eye : _x,_y,0<=_radius<=100,_amplitude>=0 : Apply fish-eye deformation on selected images.
fish_eye : -skip ${1=50},${2=50},${3=50},${4=1.2}
  -if {$4==0} -return -endif
  -e[^-1] "Apply Fish-eye effect on image$?, centered at ($1%,$2%) with radius $3% and amplitude $4."
  -v - -repeat @#
    100%,100%,1,1 -=[-1] 1,$1%,$2% -distance[-1] 1 -c[-1] 0,$3% -*[-1] -1 -n[-1] 0,1 -pow[-1] {1/$4}
    -i[-2] ({-$1/100},{1-$1/100};{-$1/100},{1-$1/100}^{-$2/100},{-$2/100};{1-$2/100},{1-$2/100}) -r[-2] [-1],[-1],1,2,3
    -n[-1] 0,{max(@{-1,w},@{-1,h})} -*[-2,-1]
    -warp[-2] [-1],1,1,1 -rm[-1]
  -mv[-1] 0 -done -v +

#@gmic transform_polar : "expr_radius",_"expr_angle",_x_center,_y_center,_borders={0|1} : Apply user-defined transform on polar representation of selected images.
transform_polar : -skip "${1=r}","${2=a}",${3=50},${4=50},${5=1}
  -e[^-1] "Apply custom polar transform with 'new_r = $1', 'new_a = $2', centered at ($3%,$4%)."
  -v -
  -repeat @#
  -p {"sqrt((max($3,100-$3)*"@{-1,w}"/100)^2 + (max($4,100-$4)*"@{-1,h}"/100)^2)"}
  -p {"$3*"@{-1,w}"/100"}
  -p {"$4*"@{-1,h}"/100"}
  -f "R ="~-3";
      r = sqrt((x-"~-2")^2 + (y-"~-1")^2);
      a = atan2(y-"~-1",x-"~-2");
      nr = $1;
      na = $2;
      i("~-2" + nr*cos(na), "~-1" + nr*sin(na), z, c, $5)"
  -pp[-3--1]
  -mv[-1] 0 -done -v +

#@gmic kaleidoscope : _cx,_cy,_radius,_angle,_borders={0,1,2} : Create kaleidoscope effect from selected images.
kaleidoscope : -skip ${1=0.5},${2=0.5},${3=100},${4=30},${5=1}
  -e[^-1] "Create kaleidoscope effect from image$?, with center ($1,$2) radius $3, angle $4."
  -v - -euclidean2polar $1,$2,1,$5 -repeat @#
    --columns[-1] 0,$3% -lines[-1] 0,$4% -r[-1] [-2],0,2 -rm[-2]
  -mv[-1] 0 -done -polar2euclidean $1,$2,1,$5 -v +

#------------------------------------
#
# Image degradation
#
#------------------------------------

#@gmic spread : _dx>=0,_dy>=0,_dz>=0 : Spread pixel values of selected images randomly along x,y and z.
spread : -skip ${1=3},${2=$1},${3=0}
  -e[^-1] "Spread pixel of image$? randomly, with amplitudes ($1,$2,$3)."
  -v - -repeat @#
    100%,100%,100%,1 [-1]x2 -noise[-3] $1,0 -noise[-2] $2,0 -noise[-1] $3,0 -a[-3--1] c -warp[-2] [-1],1 -rm[-1]
  -mv[-1] 0 -done -v +

#@gmic shade_stripes : _frequency>=0,_direction={0|1},_darkness>=0,_lightness>=0 : Add shade stripes to selected images.
shade_stripes : -skip ${1=5},${2=1},${3=0.8},${4=2}
  -v - -repeat @#
    -n[-1] 0,255
    -if $2 -v + -e[^-1] "Add vertical shaded stripes to image$?, with frequency $1, darkness $3 and lightness $4." -v - 100%
    -else -v + -e[^-1] "Add horizontal shaded stripes to image$?, with frequency $1, darkness $3 and lightness $4." -v - 1,100%
    -endif
    -noise[-1] $1,2 -distance[-1] 1
    -r[-1] [-2] -n[-1] $3,$4 -*[-1,-2] -c[-1] 0,255
  -mv[-1] 0 -done -v +

#@gmic stripes_y : _frequency>=0 : Add vertical stripes to selected images.
stripes_y : -skip ${1=10}
  -e[^-1] "Add vertical stripes to image$?, with frequency $1."
  -v - -repeat @#
    -n[-1] 0,255 100% -noise[-1] $1,2 -*[-1] 255 -r[-1] [-2]
    -*[-1] 0.15 -+[-1,-2] -c[-1] 0,255
  -mv[-1] 0 -done -v +

#@gmic damp_patch : _opacity>=0 : Add damp patches to selected images.
damp_patch : -skip ${1=0.7}
  -e[^-1] "Apply damp patches to image$?, with opacity $1."
  -v - -repeat @#
    100%,100%,1,1 -shift[-1] -2,-2 -shift[-1] 1,1
    -plasma[-1] 3,0.3 -abs[-1] -blur[-1] 1 -c[-1] 3%,15% -r[-1] [-2]
    -n[-1] $1,1 -*[-1,-2]
  -mv[-1] 0 -done -v +

#@gmic light_patch : _density>0,_darkness>=0,_lightness>=0 : Add light patches to selected images.
light_patch : -skip ${1=10},${2=0.9},${3=1.7}
  -e[^-1] "Apply light patches to image$?, with density $1, darkness $2 and lightness $3."
  -v - -repeat @#
    -n[-1] 0,255 $1,$1 -noise[-1] 40 -r[-1] [-2],5 -c[-1] 0,255
    -n[-1] $2,$3 -*[-2,-1] -c[-1] 0,255
  -mv[-1] 0 -done -v +

#@gmic noise_hurl : _amplitude>=0 : Add hurl noise to selected images.
noise_hurl : -skip ${1=10}
  -e[^-1] "Add hurl noise to image$?, with amplitude $1%."
  -v - -repeat @#
    --f[-1] 0 -noise[-1] 10 -n[-1] @{-2,m,M} 100%,100%,1,1,-2
    -noise[-1] $1,2 -t[-1] 0 -r[-1] [-2]
    -*[-2] [-1] -*[-1] -1 -+[-1] 1 -*[-3,-1] -+[-2,-1]
  -mv[-1] 0 -done -v +

#@gmic pixelize : _scale_x>0,_scale_y>0,_scale_z>0 : Pixelize selected images with specified scales.
pixelize : -skip ${1=20},${2=$1},${3=$1}
  -e[^-1] "Pixelize image$? with scales ($1%,$2%,$3%)."
  -v - -repeat @#
    (@{-1,w},@{-1,h},@{-1,d}) -r[-2] $1%,$2%,$3%,[-2],2 -r[-2] @-1 -rm[-1]
  -mv[-1] 0 -done -v +

#@gmic paper_texture : : Add paper texture to selected images.
paper_texture :
  -e[^-1] "Add paper texture to image$?."
  -v - -repeat @#
    [-1] 30%,30% -noise[-1] 1,2 -r[-1] [-2],[-2],[-2],1,0 -ifft[-1]
    -rm[-1] -shift[-1] 50%,50%,50%,0,2 -sharpen[-1] 1 -n[-1] 1,1.2 -r[-1] [-2]
    -*[-2,-1] -c[-1] [-2],[-2] -rm[-2]
  -mv[-1] 0 -done -v +

#-------------------------
#
# Color-related filters
#
#-------------------------

#@gmic apply_channels : "command",_channels={All,RGBA,RGB,Y,CbCr,Cb,Cr,L,ab,a,b,H,S,V,K,A},_normalize={0=cut|1=normalize} : Apply specified command on chosen normalized channels of each selected images.
apply_channels :

  # Process all channels.
  -if {$2==0}
    -e[^-1] "Apply command '$1' on image$?." -v -
    -repeat @# -l[-1]
      -_apply_channels[0] "$1"
      -if $3 -n[0] 0,255 -else -c[0] 0,255 -endif
    -endl -mv[-1] 0 -done

  # Process RGBA channels.
  -elif {$2==1}
    -e[^-1] "Apply command '$1' on RGBA channels of image$?." -v -
    -to_rgba -repeat @# -l[-1]
      -_apply_channels[0] "$1"
      -if $3 -n[0] 0,255 -else -c[0] 0,255 -endif
    -endl -mv[-1] 0 -done

  # Process RGB channels.
  -elif {$2==2}
    -e[^-1] "Apply command '$1' on RGB channels of image$?." -v -
    -repeat @# -l[-1]
      -split_opacity -to_rgb[0]
      -_apply_channels[0] "$1" -to_rgb[0]
      -if $3 -n[0] 0,255 -else -c[0] 0,255 -endif
      -a c
    -endl -mv[-1] 0 -done

  # Process Y channel.
  -elif {$2==3}
    -e[^-1] "Apply command '$1' on luminance of image$?." -v -
    -repeat @# -l[-1]
      -split_opacity -to_rgb[0] -rgb2ycbcr[0] -s[0] c
      -_apply_channels[0] "$1" -channels[0] 0
      -if $3 -n[0] 0,255 -else -c[0] 0,255 -endif
      -a[0-2] c -ycbcr2rgb[0] -a c
    -endl -mv[-1] 0 -done

  # Process CbCr channels.
  -elif {$2==4}
    -e[^-1] "Apply command '$1' on blue and red chrominances of image$?." -v -
    -repeat @# -l[-1]
      -split_opacity -to_rgb[0] -rgb2ycbcr[0] -s[0] c
      -_apply_channels[1] "$1" -_apply_channels[2] "$1" -channels[1,2] 0
      -if $3 -n[1,2] 0,255 -else -c[1,2] 0,255 -endif
      -a[0-2] c -ycbcr2rgb[0] -a c
    -endl -mv[-1] 0 -done

  # Process Cb channel.
  -elif {$2==5}
    -e[^-1] "Apply command '$1' on blue chrominance of image$?." -v -
    -repeat @# -l[-1]
      -split_opacity -to_rgb[0] -rgb2ycbcr[0] -s[0] c
      -_apply_channels[1] "$1" -channels[1] 0
      -if $3 -n[1] 0,255 -else -c[1] 0,255 -endif
      -a[0-2] c -ycbcr2rgb[0] -a c
    -endl -mv[-1] 0 -done

  # Process Cr channel.
  -elif {$2==6}
    -e[^-1] "Apply command '$1' on red chrominance of image$?." -v -
    -repeat @# -l[-1]
      -split_opacity -to_rgb[0] -rgb2ycbcr[0] -s[0] c
      -_apply_channels[2] "$1" -channels[2] 0
      -if $3 -n[2] 0,255 -else -c[2] 0,255 -endif
      -a[0-2] c -ycbcr2rgb[0] -a c
    -endl -mv[-1] 0 -done

  # Process L channel.
  -elif {$2==7}
    -e[^-1] "Apply command '$1' on lightness of image$?." -v -
    -repeat @# -l[-1]
      -split_opacity -to_rgb[0] -rgb2lab[0] -s[0] c
      -*[0] 2.55 -_apply_channels[0] "$1" -channels[0] 0 -/[0] 2.55
      -if $3 -n[0] 0,100 -else -c[0] 0,100 -endif
      -a[0-2] c -lab2rgb[0] -a c
    -endl -mv[-1] 0 -done

  # Process a-b channels.
  -elif {$2==8}
    -e[^-1] "Apply command '$1' on a-b channels of image$?." -v -
    -repeat @# -l[-1]
      -split_opacity -to_rgb[0] -rgb2lab[0] -s[0] c
      -+[1] 86 -*[1] 1.38587 -+[2] 108 -*[2] 1.25616 -_apply_channels[1] "$1" -_apply_channels[2] "$1"
      -channels[1,2] 0 -/[1] 1.38587 --[1] 86 -/[2] 1.25616 --[2] 108
      -if $3 -n[1] -86,98 -n[2] -108,95 -endif
      -a[0-2] c -lab2rgb[0] -a c
    -endl -mv[-1] 0 -done

  # Process a-channel.
  -elif {$2==9}
    -e[^-1] "Apply command '$1' on a-channel of image$?." -v -
    -repeat @# -l[-1]
      -split_opacity -to_rgb[0] -rgb2lab[0] -s[0] c
      -+[1] 86 -*[1] 1.38587 -_apply_channels[1] "$1" -channels[1] 0 -/[1] 1.38587 --[1] 86
      -if $3 -n[1] -86,98 -endif
      -a[0-2] c -lab2rgb[0] -a c
    -endl -mv[-1] 0 -done

  # Process b-channel.
  -elif {$2==10}
    -e[^-1] "Apply command '$1' on b-channel of image$?." -v -
    -repeat @# -l[-1]
      -split_opacity -to_rgb[0] -rgb2lab[0] -s[0] c
      -+[2] 108 -*[2] 1.25616 -_apply_channels[2] "$1" -channels[2] 0 -/[2] 1.25616 --[2] 108
      -if $3 -n[1] -108,95 -endif
      -a[0-2] c -lab2rgb[0] -a c
    -endl -mv[-1] 0 -done

  # Process H channel.
  -elif {$2==11}
    -e[^-1] "Apply command '$1' on hue of image$?." -v -
    -repeat @# -l[-1]
      -split_opacity -to_rgb[0] -rgb2hsv[0] -s[0] c
      -*[0] 0.708333 -_apply_channels[0] "$1" -channels[0] 0 -/[0] 0.708333
      -if $3 -n[0] 0,360 -else -mod[0] 360 -endif
      -a[0-2] c -hsv2rgb[0] -a c
    -endl -mv[-1] 0 -done

  # Process S channel.
  -elif {$2==12}
    -e[^-1] "Apply command '$1' on saturation of image$?." -v -
    -repeat @# -l[-1]
      -split_opacity -to_rgb[0] -rgb2hsv[0] -s[0] c
      -*[1] 255 -_apply_channels[1] "$1" -channels[1] 0 -/[1] 255
      -if $3 -n[1] 0,1 -else -c[1] 0,1 -endif
      -a[0-2] c -hsv2rgb[0] -a c
    -endl -mv[-1] 0 -done

  # Process V channel.
  -elif {$2==13}
    -e[^-1] "Apply command '$1' on value of image$?." -v -
    -repeat @# -l[-1]
      -split_opacity -to_rgb[0] -rgb2hsv[0] -s[0] c
      -*[2] 255 -_apply_channels[2] "$1" -channels[2] 0 -/[2] 255
      -if $3 -n[2] 0,1 -else -c[2] 0,1 -endif
      -a[0-2] c -hsv2rgb[0] -a c
    -endl -mv[-1] 0 -done

  # Process K channel.
  -elif {$2==14}
    -e[^-1] "Apply command '$1' on key channel of image$?." -v -
    -repeat @# -l[-1]
      -split_opacity -to_rgb[0] -rgb2cmyk[0] -s[0] c
      -_apply_channels[3] "$1" -channels[3] 0
      -if $3 -n[3] 0,255 -else -c[3] 0,255 -endif
      -a[0-3] c -cmyk2rgb[0] -a c
    -endl -mv[-1] 0 -done

  # Process Alpha channel.
  -else
    -e[^-1] "Apply command(s) '$1' on alpha channel of image$?." -v -
    -repeat @# -l[-1]
      -to_rgba -split_opacity
      -_apply_channels[1] "$1" -channels[1] 0
      -if $3 -n[1] 0,255 -else -c[1] 0,255 -endif
      -a c
    -endl -mv[-1] 0 -done
  -endif
  -v +

_apply_channels :
  $* -k[0]

#@gmic to_gray : : Force selected images to be in GRAY mode.
to_gray :
  -e[^-1] "Force image$? to be in GRAY mode."
  -v - -repeat @#
    -if {@{-1,s}>4} -error "Image ["@{<,-1}"] is not a G,GA,RGB or RGBA image."
    -elif {@{-1,s}>=3} -channels[-1] 0,2 -luminance[-1]
    -elif {@{-1,s}==2} -r[-1] 100%,100%,100%,1,0
    -endif
  -mv[-1] 0 -done -v +

#@gmic to_graya : : Force selected images to be in GRAYA mode.
to_graya :
  -e[^-1] "Force image$? to be in GRAYA mode."
  -v - -repeat @#
    -if {@{-1,s}>4} -error "Image ["@{<,-1}"] is not a G,GA,RGB or RGBA image."
    -elif {@{-1,s}==4} --channels[-1] 3 -r[-2] 100%,100%,100%,3,0 -luminance[-2] -a[-2,-1] c
    -elif {@{-1,s}==3} -luminance[-1] 100%,100%,100%,1,255 -a[-2,-1] c
    -elif {@{-1,s}==1} 100%,100%,100%,1,255 -a[-2,-1] c
    -endif
  -mv[-1] 0 -done -v +

#@gmic to_rgb : : Force selected images to be in RGB mode.
to_rgb :
  -e[^-1] "Force image$? to be in RGB mode."
  -v - -repeat @#
    -if {@{-1,s}>4} -error "Image ["@{<,-1}"] is not a G,GA,RGB or RGBA image."
    -elif {@{-1,s}==4} -channels[-1] 0,2
    -elif {@{-1,s}==2} -r[-1] 100%,100%,100%,1,0 -r[-1] 100%,100%,100%,3
    -elif {@{-1,s}==1} -r[-1] 100%,100%,1,3
    -endif
  -mv[-1] 0 -done -v +

#@gmic to_rgba : : Force selected images to be in RGBA mode.
to_rgba :
  -e[^-1] "Force image$? to be in RGBA mode."
  -v - -repeat @#
    -if {@{-1,s}>4} -error "Image ["@{<,-1}"] is not a G,GA,RGB or RGBA image."
    -elif {@{-1,s}==3} 100%,100%,1,1,255 -a[-2,-1] c
    -elif {@{-1,s}==2} -s[-1] c -r[-2] 100%,100%,100%,3 -a[-2,-1] c
    -elif {@{-1,s}==1} -r[-1] 100%,100%,1,3 100%,100%,1,1,255 -a[-2,-1] c
    -endif
  -mv[-1] 0 -done -v +

#@gmic to_colormode : mode={0=adaptive,1=G,2=GA,3=RGB,4=RGBA} : Force selected images to be in a given color mode.
to_colormode : -skip ${1=0}
  -if {$1==1} -to_gray
  -elif {$1==2} -to_graya
  -elif {$1==3} -to_rgb
  -elif {$1==4} -to_rgba
  -else
    -p 0 -repeat @#
      -if {@{@{>,-1},s}>4} -error "Image ["@{>,-1}"] is not a G,GA,RGB or RGBA image."
      -else -pr[-1] {max(~-1,@{@{>,-1},s})}
      -endif
    -done -to_colormode ~-1 -pp[-1]
  -endif

#@gmic remove_opacity : : Remove opacity channel of selected images.
remove_opacity :
  -e[^-1] "Remove opacity channel of image$?."
  -v - -repeat @#
    -if {@{-1,s}==2} -r[-1] 100%,100%,100%,1,0
    -elif {@{-1,s}==4} -r[-1] 100%,100%,100%,3,0
    -endif
  -mv[-1] 0 -done -v +

#@gmic select_color : _tolerance[%]>=0,col1,..,colN : Select pixels with specified color in selected images.
select_color :
  -e[^-1] "Select color (${3*}) in image$?, with tolerance $1."
  -v - -repeat @#
    (${3*}) -unroll[-1] c -r[-1] [-2] --[-2,-1] -norm[-1] -t[-1] $1 -*[-1] -1 -+[-1] 1
  -mv[-1] 0 -done -v +

#@gmic replace_color : _tolerance[%]>=0,_smoothness[%]>=0,src1,...,srcN,dest1,...,destN : Replace pixels from/to specified colors in selected images.
replace_color :
  -v - (${3*}) -unroll[-1] c -s[-1] c,2
  -v + -e[^-1] "Replace color ("@-2") to color ("@-1") in image$?, with tolerance $1 and smoothness $2." -rm[-2,-1]
  -v - -repeat @#
    (${3*}) -unroll[-1] c -s[-1] c,2 -r[-2,-1] 1,1,1,@{-3,s} --[-1] [-2]
    -r[-2] [-3] --[-2] [-3] -norm[-2] -t[-2] $1 -blur[-2] $2 -*[-2] -1 -+[-2] 1
    -mv[-2] @# -r[-2] [-1],[-1] -*[-2,-1] -+[-2,-1]
  -mv[-1] 0 -done -v +

#@gmic fill_color : col1,...,colN : Fill selected images with specified color.
fill_color :
  -e[^-1] "Fill image$? with color ($*)."
  -v - -repeat @#
    ($*) -unroll[-1] c -to_colormode[-1] @{-2,s}
    (@{-2,w},@{-2,h},@{-2,d}) -rm[-3] -r[-2] @-1 -rm[-1]
  -mv[-1] 0 -done -v +

#@gmic luminance : : Compute luminance of selected images.
luminance :
  -e[^-1] "Compute luminance of image$?."
  -v - -to_rgb -rgb2ycbcr -channels 0 -v +

#@gmic mix_rgb : a11,a12,a13,a21,a22,a23,a31,a32,a33 : Apply 3x3 specified matrix to RGB colors of selected images.
mix_rgb : -skip ${1=1},${2=0},${3=0},${4=0},${5=1},${6=0},${7=0},${8=0},${9=1}
  -e[^-1] "Apply matrix [ $1 $2 $3 ; $4 $5 $6 ; $7 $8 $9 ] to RGB colors of image$?."
  -v - -repeat @#
    -r[-1] 100%,100%,1,3,0,2 -s[-1] c
    --*[-3] $4 --*[-3] $5 -+[-1,-2] --*[-2] $6 -+[-1,-2]
    --*[-4] $7 --*[-4] $8 -+[-1,-2] --*[-3] $9 -+[-1,-2]
    -*[-5] $1 -*[-4] $2 -*[-3] $3 -+[-5--3] -a[-3--1] c
  -mv[-1] 0 -done -v +

#@gmic mix_channels : "(a00,...,aMN)" : Apply specified matrix to channels of selected images.
mix_channels :
  -e[^-1] "Apply matrix $1 to channels of image$?."
  -v - -repeat @#
    -p @{-1,w},@{-1,h},@{-1,d}
    -r[-1] {@{-1,w}*@{-1,h}*@{-1,d}},@{-1,s},1,1,-1
    -i[-2] $* -**[-2,-1]
    -r[-1] ~-1,@{-1,h},-1 -pp[-1]
  -mv[-1] 0 -done -v +

#@gmic solarize : : Solarize selected images.
solarize :
  -e[^-1] "Solarize image$?."
  -v - -luminance -n 0,128 -map 1 -v +

#@gmic sepia : : Apply sepia tones effect on selected images.
sepia :
  -e[^-1] "Apply sepia tones effect on image$?."
  -v - -luminance (0,44,115,143,196,244^0,20,84,119,184,235^0,5,44,73,144,200)
  -r[-1] 256,1,1,3,3 -map[0--2] [-1] -rm[-1] -v +

#@gmic split_opacity : : Split color and opacity parts of selected images.
split_opacity :
  -e[^-1] "Split color and opacity parts of image$?."
  -v - -repeat @#
    -if {@{-1,s}==2} -s[-1] c -mv[-2,-1] 0
    -elif {@{-1,s}==4} -s[-1] c -a[-4--2] c -mv[-2,-1] 0
    -else -mv[-1] 0
    -endif
  -done -v +

#@gmic red_eye : 0<=_threshold<=100,_smoothness>=0,0<=attenuation<=1 : Attenuate red-eye effect in selected images.
red_eye : -skip ${1=75},${2=3.5},${3=0.1}
  -e[^-1] "Attenuate red-eye effect in image$?, with threshold $1, smoothness $2 and attenuation $3."
  -v - -to_rgb -rgb2ycbcr -repeat @#
    -s[-1] c --[-1] 128 --t[-1] $1% -blur[-1] $2 -sqrt[-1] -*[-1] -1 -+[-1] 1
    -n[-1] $3,1 -*[-2,-1] -+[-1] 128 -a[-3--1] c -ycbcr2rgb[-1]
  -mv[-1] 0 -done -v +

#-------------------------------
#
# Image fading and composition
#
#-------------------------------

#@gmic fade_x : 0<=_start<=100,0<=_end<=100 : Create horizontal fading from selected images.
fade_x : -skip ${1=30},${2=70}
  -e[^-1] "Create ($1%,$2%) horizontal fading from image$?."
  -v - -repeat {@#/2}
    (0,1) -_fade $1,$2
  -mv[-1] 0 -done -v +

#@gmic fade_y : 0<=_start<=100,0<=_end<=100 : Create vertical fading from selected images.
fade_y : -skip ${1=30},${2=70}
  -e[^-1] "Create ($1%,$2%) vertical fading from image$?."
  -v - -repeat {@#/2}
    (0;1) -_fade $1,$2
  -mv[-1] 0 -done -v +

#@gmic fade_z : 0<=_start<=100,0<=_end<=100 : Create transversal fading from selected images.
fade_z : -skip ${1=30},${2=70}
  -e[^-1] "Create ($1%,$2%) transversal fading from image$?."
  -v - -repeat {@#/2}
    (0/1) -_fade $1,$2
  -mv[-1] 0 -done -v +

#@gmic fade_radial : 0<=_start<=100,0<=_end<=100 : Create radial fading from selected images.
fade_radial : -skip ${1=30},${2=70}
  -e[^-1] "Create ($1%,$2%) radial fading from image$?."
  -v - -repeat {@#/2}
    100%,100% -point 50%,50%,0,1,1 -distance[-1] 1 -_fade $1,$2
  -mv[-1] 0 -done -v +

#@gmic fade_diamond : 0<=_start<=100,0<=_end<=100 : Create diamond fading from selected images.
fade_diamond : -skip ${1=70},${2=90}
  -e[^-1] "Create ($1%,$2%) diamond-shaped fading from image$?."
  -v - -repeat {@#/2}
    (0,1,0;1,1,1;0,1,0) -_fade $1,$2
  -mv[-1] 0 -done -v +

#@gmic fade_linear : _angle,0<=_start<=100,0<=_end<=100 : Create linear fading from selected images.
fade_linear : -skip ${1=45},${2=30},${3=70}
  -e[^-1] "Create ($2%,$3%) linear fading from image$?, with angle $1."
  -v - -repeat {@#/2}
     64,64,1,1,"x*cos($1*pi/180) + y*sin($1*pi/180)" -_fade $2,$3
  -mv[-1] 0 -done -v +

_fade :
  -r[-2] [-3],5 -r[-1] [-2],3 -c[-1] $1%,$2% -n[-1] 0,1 --*[-1] -1 -+[-1] 1 -*[-4,-1] -*[-2,-1] -+[-2,-1]

#@gmic compose_rgba : : Compose selected RGBA images two-by-two, over RGB background.
compose_rgba :
  -e[^-1] "Compose RGBA image$? two-by-two, over RGB background."
  -v - -repeat {@#/2}
    -to_rgb[-2] -r[-1] [-2],[-2],1,100% -to_rgba[-1]
    -s[-1] c -a[-4--2] c -/[-1] 255 [-1] -negative[-1] -r[-4--1] 100%,100%,1,3
    -*[-4,-1] -*[-2,-1] -+[-2,-1]
  -mv[-1] 0 -done -v +

#@gmic compose_average : : Compose selected images two-by-two, using average mode.
compose_average :
  -e[^-1] "Compose image$? two-by-two, using average mode."
  -v - -remove_opacity -to_colormode[0--1] @{0,s} -repeat {@#/2}
    -r[-1] [-2],0 -+[-2,-1] -/[-1] 2
  -mv[-1] 0 -done -v +

#@gmic compose_multiply : : Compose selected images two-by-two, using multiply mode.
compose_multiply :
  -e[^-1] "Compose image$? two-by-two, using multiply mode."
  -v - -remove_opacity -to_colormode[0--1] @{0,s} -repeat {@#/2}
    -r[-1] [-2],0 -*[-2,-1] -/[-1] 256
  -mv[-1] 0 -done -v +

#@gmic compose_screen : : Compose selected images two-by-two, using screen mode.
compose_screen :
  -e[^-1] "Compose image$? two-by-two, using screen mode."
  -v - -remove_opacity -to_colormode[0--1] @{0,s} -repeat {@#/2}
    -r[-1] [-2],0 --[-2,-1] 255 -*[-2,-1] -/[-1] 256 --[-1] 255 -*[-1] -1
  -mv[-1] 0 -done -v +

#@gmic compose_darken : : Compose selected images two-by-two, using darken mode.
compose_darken :
  -e[^-1] "Compose image$? two-by-two, using darken mode."
  -v - -remove_opacity -to_colormode[0--1] @{0,s} -repeat {@#/2}
    -r[-1] [-2],0 -min[-2] [-1] -rm[-1]
  -mv[-1] 0 -done -v +

#@gmic compose_lighten : : Compose selected images two-by-two, using lighten mode.
compose_lighten :
  -e[^-1] "Compose image$? two-by-two, using lighten mode."
  -v - -remove_opacity -to_colormode[0--1] @{0,s} -repeat {@#/2}
    -r[-1] [-2],0 -max[-2] [-1] -rm[-1]
  -mv[-1] 0 -done -v +

#@gmic compose_difference : : Compose selected images two-by-two, using difference mode.
compose_difference :
  -e[^-1] "Compose image$? two-by-two, using difference mode."
  -v - -remove_opacity -to_colormode[0--1] @{0,s} -repeat {@#/2}
    -r[-1] [-2],0 --[-2,-1] -abs[-1]
  -mv[-1] 0 -done -v +

#@gmic compose_negation : : Compose selected images two-by-two, using negation mode.
compose_negation :
  -e[^-1] "Compose image$? two-by-two, using negation mode."
  -v - -remove_opacity -to_colormode[0--1] @{0,s} -repeat {@#/2}
    -r[-1] [-2],0 -+[-2,-1] --[-1] 255 -abs[-1] --[-1] 255 -*[-1] -1
  -mv[-1] 0 -done -v +

#@gmic compose_exclusion : : Compose selected images two-by-two, using exclusion mode.
compose_exclusion :
  -e[^-1] "Compose image$? two-by-two, using exclusion mode."
  -v - -remove_opacity -to_colormode[0--1] @{0,s} -repeat {@#/2}
    -r[-1] [-2],0 --*[-2] [-1] -/[-1] -128 -+[-3--1]
  -mv[-1] 0 -done -v +

#@gmic compose_overlay : : Compose selected images two-by-two, using overlay mode.
compose_overlay :
  -e[^-1] "Compose image$? two-by-two, using overlay mode."
  -v - -remove_opacity -to_colormode[0--1] @{0,s} -repeat {@#/2}
    -r[-1] [-2],0
    --t[-2] 128
    --*[-3] [-2] -/[-1] 128
    --[-4,-3] 255 -*[-4,-3] -/[-3] 128 --[-3] 255 -*[-3] -1
    -*[-3] [-2] -*[-2] -1 -+[-2] 1 -*[-2,-1]
    -+[-2,-1]
  -mv[-1] 0 -done -v +

#@gmic compose_hardlight : : Compose selected images two-by-two, using hard light mode.
compose_hardlight :
  -e[^-1] "Compose image$? two-by-two, using hard light mode."
  -v - -remove_opacity -to_colormode[0--1] @{0,s} -repeat {@#/2}
    -r[-1] [-2],0
    --t[-1] 128
    --*[-3] [-2] -/[-1] 128
    --[-4,-3] 255 -*[-4,-3] -/[-3] 128 --[-3] 255 -*[-3] -1
    -*[-3] [-2] -*[-2] -1 -+[-2] 1 -*[-2,-1]
    -+[-2,-1]
  -mv[-1] 0 -done -v +

#@gmic compose_softlight : : Compose selected images two-by-two, using soft light mode.
compose_softlight :
  -e[^-1] "Compose image$? two-by-two, using soft light mode."
  -v - -remove_opacity -to_colormode[0--1] @{0,s} -repeat {@#/2}
    -r[-1] [-2],0 -/[-2,-1] 256 --*[-2] [-1] -*[-1] 2 -sqr[-3] -*[-2] [-3] -*[-2] -2 -+[-3--1] -*[-1] 256
  -mv[-1] 0 -done -v +

#@gmic compose_dodge : : Compose selected images two-by-two, using dodge mode.
compose_dodge :
  -e[^-1] "Compose image$? two-by-two, using dodge mode."
  -v - -remove_opacity -to_colormode[0--1] @{0,s} -repeat {@#/2}
    -r[-1] [-2],0 --[-1] 255.1 -/[-2,-1] -*[-1] -256 -c[-1] 0,255
  -mv[-1] 0 -done -v +

#@gmic compose_colorburn : : Compose selected images two-by-two, using color burn mode.
compose_colorburn :
  -e[^-1] "Compose image$? two-by-two, using colorburn mode."
  -v - -remove_opacity -to_colormode[0--1] @{0,s} -repeat {@#/2}
    -r[-1] [-2],0 --[-2] 255 -+[-1] 0.1 -/[-2,-1] -*[-1] 256 -+[-1] 255 -c[-1] 0,255
  -mv[-1] 0 -done -v +

#@gmic compose_reflect : : Compose selected images two-by-two, using reflect mode.
compose_reflect :
  -e[^-1] "Compose image$? two-by-two, using reflect mode."
  -v - -remove_opacity -to_colormode[0--1] @{0,s} -repeat {@#/2}
    -r[-1] [-2],0 -sqr[-2] --[-1] 255.1 -/[-2,-1] -*[-1] -1 -c[-1] 0,255
  -mv[-1] 0 -done -v +

#@gmic compose_freeze : : Compose selected images two-by-two, using freeze mode.
compose_freeze :
  -e[^-1] "Compose image$? two-by-two, using freeze mode."
  -v - -remove_opacity -to_colormode[0--1] @{0,s} -repeat {@#/2}
    -r[-1] [-2],0 --[-2] 255 -sqr[-2] -+[-1] 0.1 -/[-2,-1] --[-1] 255 -*[-1] -1 -c[-1] 0,255
  -mv[-1] 0 -done -v +

#@gmic compose_stamp : : Compose selected images two-by-two, using stamp mode.
compose_stamp :
  -e[^-1] "Compose image$? two-by-two, using stamp mode."
  -v - -remove_opacity -to_colormode[0--1] @{0,s} -repeat {@#/2}
    -r[-1] [-2],0 -*[-1] 2 -+[-2,-1] --[-1] 255 -c[-1] 0,255
  -mv[-1] 0 -done -v +

#@gmic compose_interpolation : : Compose selected images two-by-two, using interpolation mode.
compose_interpolation :
  -e[^-1] "Compose image$? two-by-two, using interpolation mode."
  -v - -remove_opacity -to_colormode[0--1] @{0,s} -repeat {@#/2}
    -r[-1] [-2],0 -*[-2,-1] 0.012271846 -cos[-2,-1] -/[-2,-1] -4 -+[-2,-1] -+[-1] 0.5 -*[-1] 256
  -mv[-1] 0 -done -v +

#@gmic compose_xor : : Compose selected images two-by-two, using xor mode.
compose_xor :
  -e[^-1] "Compose image$? two-by-two, using xor mode."
  -v - -remove_opacity -to_colormode[0--1] @{0,s} -repeat {@#/2}
    -r[-1] [-2],0 -xor[-2,-1]
  -mv[-1] 0 -done -v +

#@gmic compose_edges : smoothness=0.8 : Compose selected images togethers using edge composition.
compose_edges : -skip ${1=0.8}
  -e[^-1] "Compose image$? using edge composition, with smoothness $1."
  -if {@#>1} -v - -to_rgb -repeat @#
    --gradient_norm[-1] -+[-1] 1 -blur[-1] $1 -n[-1] 1,10 -sqr[-1] -s[-2] c -*[-4--2] [-1] -a[-4--1] c
  -mv[-1] 0 -done -r[1--1] [0],0,0,0.5,0.5 -+ -s[-1] c -/[-4--2] [-1] -rm[-1] -a[-3--1] c -v + -endif

#@gmic compose_fade : : Compose selected images togethers using a given fading (defined as the latest image).
compose_fade :
  -e[^-1] "Compose image$? using fading composition."
  -v - -r[1--1] [0],[0],[0],100%,3
  -r[1--2] 100%,100%,100%,[0] -channels[-1] 0
  -repeat {@#-1}
    ---[-1] @{>,-1} -abs[-1] --[-1] 1 -*[-1] -1 -max[-1] 0 -*[@{>,-1},-1]
  -done
  -rm[-1] -+ -v +

#--------------------------------------
#
# Motion-related and video processing
#
#--------------------------------------

#@gmic cross_correlation : : Compute cross-correlation using two-by-two selected images.
cross_correlation :
  -e[^-1] "Compute cross-correlation using two-by-two image$?."
  -v - -repeat {@#/2}
    -norm[-2,-1] -fft[-2] -fft[-1] [-2,-1] -mul[-2] [-5] -mul[-1] [-6]
    --[-2,-1] -*[-5,-3] -*[-3,-2] -+[-3,-2] -ifft[-2,-1] -rm[-1]
  -mv[-1] 0 -done -v +

#@gmic normalized_cross_correlation : : Compute normalized cross-correlation using two-by-two selected images.
normalized_cross_correlation :
  -e[^-1] "Compute normalized cross-correlation using two-by-two image$?."
  -v - -repeat {@#/2}
    -norm[-2,-1] -fft[-2] -fft[-1] [-2,-1] -mul[-2] [-5] -mul[-1] [-6]
    --[-2,-1] -*[-5,-3] -*[-3,-2] -+[-3,-2] [-2,-1] -a[-2,-1] c -norm[-1]
    -/[-3] [-1] -/[-2,-1] -ifft[-2,-1] -rm[-1]
  -mv[-1] 0 -done -v +

#@gmic phase_correlation : : Estimate translation vector using two-by-two selected images.
phase_correlation :
  -e[^-1] "Estimate translation vector using two-by-two image$?."
  -v - -repeat {@#/2}
    -normalized_cross_correlation[-2,-1]
    (@{-1,C}) -*[-1] 2 -s[-1] x -rm[-1]
    -if {@-3>@{-4,w}} --[-3] @{-4,w} --[-3] @{-4,w} -endif
    -if {@-2>@{-4,h}} --[-2] @{-4,h} --[-2] @{-4,h} -endif
    -if {@-1>@{-4,d}} --[-1] @{-4,d} --[-1] @{-4,d} -endif
    -a[-3--1] c -/[-1] 2 -*[-1] -1 -rm[-2]
  -mv[-1] 0 -done -v +

#@gmic morph : nb_frames>0,_smoothness>=0,_precision>0 : Create morphing sequence between selected images.
morph : -skip $1,${2=0.2},${3=0.1}
  -e[^-1] "Create morphing sequence between image$?, with $1 intra-frames, smoothness $2 and precision $3.\n"
  -v - -r[1--1] [0],3 -i[0] (@#) --[0] 1 -repeat @0
   -v + -e[] "\r > Morph image "@{>,-1}" to image "{@{>,-1}+1}".    " -v -
    --equalize[-2,-1] 256 -n[-2,-1] 0,255
    --displacement[-2] [-1],$2,$3 --warp[-5] [-1],1,1,1,$1 -a[-$1--1] z -rm[-2]
    --displacement[-2] [-3],$2,$3 --warp[-5] [-1],1,1,1,$1 -a[-$1--1] z -rm[-7--4,-2]
    (1/0) -r[-1] [-2],3 -*[-3] [-1] -*[-2,-1] -mirror[-1] z -+[-2,-1] -s[-1] z
    -mv[-$1--1] 1 -mv[1] @#
  -done -mv[-1] 1 -rm[0] -v +

#@gmic register_nonrigid : _smoothness>=0,_precision>0,_nb_scale>=0 : Register selected images with non-rigid warp.
register_nonrigid : -skip ${1=0.2},${2=0.1},${3=0}
  -e[^-1] "Register image$? with non-rigid warp, smoothness $1, precision $2 and $3 scale(s)."
  -v - --equalize[0] 256 -n[-1] 0,255 -mv[-1] 1
  -repeat @# -if {@{>,-1}>1}
    --equalize[-1] 256 -n[-1] 0,255 -displacement[-1] [1],$1,$2,$3
    -warp[-2] [-1],1,1,1 -rm[-1]
  -mv[-1] 2 -endif -done -rm[1] -v +

#@gmic register_rigid : _smoothness>=0 : Register selected images with rigid warp.
register_rigid : -skip ${1=1}
  -e[^-1] "Register image$? with rigid warp and smoothness $1."
  -v - --equalize[0] 256 -blur[-1] $1 -n[-1] 0,255 -mv[-1] 1
  -repeat @# -if {@{>,-1}>1}
    --equalize[-1] 256 -blur[-1] $1 -n[-1] 0,255 --phase_correlation[1,-1] -rm[-2] -*[-1] -1
    -shift[-2] @-1,0,1 -rm[-1]
  -mv[-1] 2 -endif -done -rm[1] -v +

#@gmic deinterlace : _method={0|1} : Deinterlace selected images ('method' can be { 0=standard or 1=motion-compensated }).
deinterlace : -skip ${1=0}
  -if $1 -e[^-1] "Deinterlace image$? with motion-compensated method."
  -else  -e[^-1] "Deinterlace image$? with standard method."
  -endif
  -v - -repeat @#
    -i[-2] (@{-1,w},@{-1,h})
    -if {$1==0}
      -l[-1] -s y -a[0--1:2] y -a[1--1] y -r[-2] [-1],0 -r[-2,-1] 100%,200%,100%,100%,5 -+[-2,-1] -/[-1] 2 -endl
    -else
      -l[-1] -s y -a[0--1:2] y -a[1--1] y -r[-2] [-1],0 -r[-2,-1] 100%,200%,1,100%,5
      --displacement[-2] [-1],0.05 -warp[-3] [-1],1,1,1 -rm[-1] -+[-2,-1] -/[-1] 2 -endl
    -endif
    -r[-1] @-2 -rm[-2]
  -mv[-1] 0 -done -v +

#@gmic animate : filter_name,(params_start;..;..),(params_end;..;..),nb_frames>=0,_output_frames={0|1},_filename : Animate filter from starting parameters to ending parameters.
animate : -skip ${1=30},${2=0},${3=""},${4=0},${5=1},${6=""}
  -if {isval($1)}
    -if $2 -e[0--4] "Animate image$?, with a delay of $1 ms, and ping-pong mode."
    -else -e[0--4] "Animate image$?, with a delay of $1 ms."
    -endif
    -if {!@#} -return -endif
    -v -
    -p $1    # Animation speed
    -p 1     # Animation direction.
    -p 0     # Current frame.
    -do
      -w[~-1] -1,-1,1,0,@{~-1,b}.@{~-1,x}
      -pr[-1] {~-1+~-2}
      -if $2
        -if {~-1==-1} -pr[-1] 0 -pr[-2] 1
        -elif {~-1==@#} -pr[-1] {@#-1} -pr[-2] -1
        -endif
      -else -pr[-1] {~-1%@#}
      -endif
      -wait ~-3
      -if {(@{!,CTRLLEFT}" || "@{!,CTRLRIGHT})" && "@{!,D}} -w[] {round(@{!,w}*1.5)},{round(@{!,h}*1.5)} -wait -1 -endif # Increase window size.
      -if {(@{!,CTRLLEFT}" || "@{!,CTRLRIGHT})" && "@{!,C}} -w[] {round(@{!,w}/1.5)},{round(@{!,h}/1.5)} -wait -1 -endif # Decrease window size.
      -if {(@{!,CTRLLEFT}" || "@{!,CTRLRIGHT})" && "@{!,R}} -w[] @{0,w},@{0,h} -wait -1 -endif                           # Reset window size.
      -if @{!,o} -pr[-3] {min(500,max(10,~-3+10*@{!,o}))} -wait -1 -endif
    -while {@!&&!@{!,Q}&&!@{!,ESC}}
    -pp[-3--1] -v +
  -else
    -e[0--3] "Compute animated version of filter '$1', from parameters $2 to $3 with $4 frames."
    -if {!($5||narg($6))} -return -endif
    -v -
    -i[0] $2 -i[1] $3 -a[0,1] x -r[0] $4,100%,1,1,3
    -progress 0 -repeat {@#-1}
      -v + -e[] "" -v -
      --l[0,1]
      -repeat $4
        --columns[0] @{>,-1} -mv[-1] 0
        --l[0,2] -$1[1] @0 -rm[0]
        -if {narg($6)} -push_filename $6,@{>,-2},@{>,-1} -o[-1] ~-1 -pp[-1] -endif
        -endl -rm[0]
        -if {!$5} -rm[-1] -endif
        -progress {100*(@{>,-1}+1)/$4}
        -v + -e[] "\r > Animate image "@{>,-2}" : Frame "{@{>,-1}+1}"/$4    " -v -
      -done -rm[0] -if $5 -rm[0] -endif
    -endl -rm[1] -done -rm[0] -v +
  -endif

#-------------------------
#
#  3D-related filters
#
#-------------------------

#@gmic animate3d : _width>0,_height>0,_dx,_dy,_dz,_zoom>=0,_filename : Animate selected 3D objects in a window.
animate3d : -skip ${1=640},${2=480},${3=0},${4=10},${5=0},${7=""} -check ${6=1}>=0
  -e[^-1] "Animate 3D object$?, in a $1x$2 window with angle velocities ($3,$4,$5)."
  -v - -repeat @#
    --n3d[@{>,-1}] -*3d[-1] {$6*min($1,$2)/1.5} -c3d[-1] (0,0,0)
    -p[0] 0
    -do
       --rot3d[-2] 1,0,0,@{-1,0} -rot3d[-1] 0,1,0,@{-2,1} -rot3d[-1] 0,0,1,@{-2,2} ($3,$4,$5) -+[-3,-1]
       $1,$2,1,3,64 -object3d[-1] [-2],50%,50%,0,1
       -if {narg($7)} -push_filename $7,@{>,-1},~0 -o[-1] ~-1 -pp[-1] -pr[0] {~0+1} -endif
       -w[-1] @{-1,w},@{-1,h},0,0,@{@{>,-1},n} -wait 20 -rm[-2,-1]
    -while {@!" && "!@{!,ESC}" && "!@{!,Q}} -rm[-1] -w 0
    -pp[0]
  -done -v +

#@gmic imagecube3d : : Create 3D mapped cubes from selected images.
imagecube3d :
  -e[^-1] "Generated 3D mapped cube frome image$?."
  -v - -repeat @#
    -p[0] {@{-1,w}-1} -p[1] {@{-1,h}-1}
    -i[-2] (67.5;73.5;109.5;103.5;51.5;100.5;\  # Magick number for CImg3d.
            8;6;\                               # Number of vertices and primitives.
            -0.5;-0.5;-0.5;\                    # Vertex coordinates.
            0.5;-0.5;-0.5;\
            0.5;0.5;-0.5;\
            -0.5;0.5;-0.5;\
            -0.5;-0.5;0.5;\
            0.5;-0.5;0.5;\
            0.5;0.5;0.5;\
            -0.5;0.5;0.5;\
            12;0;3;2;1;0;0;0;~1;~0;~1;~0;0;\    # Primitives description.
            12;1;2;6;5;0;0;0;~1;~0;~1;~0;0;\
            12;5;6;7;4;0;0;0;~1;~0;~1;~0;0;\
            12;4;7;3;0;0;0;0;~1;~0;~1;~0;0;\
            12;4;0;1;5;0;0;0;~1;~0;~1;~0;0;\
            12;3;7;6;2;0;0;0;~1;~0;~1;~0;0;\
            -128;@{-1,w};@{-1,h};@{-1,s})       # Texture map for the first face.
    -pp[0,1] -unroll[-1] y
    (-128;0;0;0;-128;0;0;0;-128;0;0;0;-128;0;0;0;-128;0;0;0;1;1;1;1;1;1)  # Other faces and opacities.
    -a[-3--1] y
  -mv[-1] 0 -done -v +

#@gmic imagepyramid3d : : Create 3D mapped pyramides from selected images.
imagepyramid3d :
  -e[^-1] "Generated 3D mapped pyramids frome image$?."
  -v - -repeat @#
    -p[0] {@{-1,w}-1} -p[1] {@{-1,h}-1} -p[2] {@{-1,w}/2}
    -i[-2] (67.5;73.5;109.5;103.5;51.5;100.5;\  # Magick number for CImg3d.
            5;5;\                               # Number of vertices and primitives.
            -0.5;-0.5;-0.5;\                    # Vertex coordinates.
            0.5;-0.5;-0.5;\
            0.5;0.5;-0.5;\
            -0.5;0.5;-0.5;\
            0;0;0.5;\
            12;0;3;2;1;0;0;0;~1;~0;~1;~0;0;\    # Primitives description.
            9;0;4;3;0;~1;~2;0;~0;~1;\
            9;1;4;0;0;~1;~2;0;~0;~1;\
            9;2;4;1;0;~1;~2;0;~0;~1;\
            9;3;4;2;0;~1;~2;0;~0;~1;\
            -128;@{-1,w};@{-1,h};@{-1,s})       # Texture map for the first face.
    -pp[0-2] -unroll[-1] y
    (-128;0;0;0;-128;0;0;0;-128;0;0;0;-128;0;0;0;1;1;1;1;1)  # Other faces and opacities.
    -a[-3--1] y
  -mv[-1] 0 -done -v +

#@gmic text3d : "text",_font_height>0,_depth>0,_smoothness : Create a 3D text object from specified text.
text3d : -skip ${2=57},${3=10},${4=1.5}
  -e[^-1] "Generate 3D text object '$1' with size $2, depth $3 and smoothness $4."
  -v - -i 1024,{10*$2},1,1 -text[-1] "$1",0,0,$2,1,1 -autocrop[-1] 0
  -r[-1] 100%,100%,$3 -r[-1] {@{-1,w}+12},{@{-1,h}+12},{@{-1,d}+12},1,0,0,0.5,0.5,0.5
  -blur[-1] $4 -n[-1] 0,1 -isosurface3d[-1] 0.5 -r3d[-1] -v +

#@gmic gmic3d : : Create a 3D G'MIC logo.
gmic3d :
  -e[^-1] "Generate 3D G'MIC logo."
  -v -
  -text3d G,60,20,2 -col3d[-1] 16,64,255
  -text3d \',60,20,2 -+3d[-1] 30 -col3d[-1] 64,128,255
  -text3d M,60,20,2 -+3d[-1] 40 -col3d[-1] 96,196,255
  -text3d I,60,20,2 -+3d[-1] 70 -col3d[-1] 64,128,255
  -text3d C,60,20,2 -+3d[-1] 95 -color3d[-1] 16,64,255
  -sphere3d 8 -+3d[-1] 85,-10,15 -col3d[-1] 192,128,255
  -+3d[-6--1] -c3d[-1]
  -repeat 30
    -box3d {min(3+@{<,-1}/2,10)} -col3d[-1] {30*@{>,-1}},{20+80*@{>,-1}},{10*@{>,-1}},0.5
    -rot3d[-1] 1,1,1,{@{>,-1}*12}
    -+3d[-1] {80*cos(0.5+1.02*@{>,-1}*12*pi/180)},{30*sin(0.8+@{>,-1}*12*pi/180)},{2*@{>,-1}-75}
  -done
  -+3d[-30--1] -+3d[-1] 0,5,30 -+3d[-2--1]
  -v +

#-------------------------
#
# Interactive demos
#
#-------------------------

#@gmic x_mandelbrot : _julia={0|1},_c0r,_c0i : Launch Mandelbrot/Julia explorer.
x_mandelbrot : -skip ${1=0},${2=0.317},${3=0.03}
  -e[] "\n
------ Mandelbrot/Julia explorer -----------------\n
----\n
---- Select zooming region with mouse.\n
---- Click once to reset zoom factor.\n
---- Keys 'ESC' or 'Q' to exit.\n
---- Key 'C' to print current fractal coordinates.\n
----\n
--------------------------------------------------"

  # Init variables and display.
  -v -
  -rm -w 512,512,0,0 -_x_mandelbrot_coords $1 -_x_mandelbrot_palette

  # Start event loop.
  -do
    -p {min(@{!,w},@{!,h})}                                                                               # Push desired window dimension.
    ~-1,~-1 -mandelbrot[-1] @0,256,$1,{if($1,$2,0)},{if($1,$3,0)} -map[-1] [1]                    # Render fractal.
    -if $1 -w[-1] ~-1,~-1,0,0,"Julia set c=("@{0,0}","@{0,1}")-("@{0,2}","@{0,3}"), c0=($2,$3)"   # Display on window.
    -else -w[-1] ~-1,~-1,0,0,"Mandelbrot set c=("@{0,0}","@{0,1}")-("@{0,2}","@{0,3}")" -endif
    -p @{-1,w} -p @{-1,h} -select[-1] 2                                                                   # Get the user selection.

    -if {@{-1,0}>0}                                                                      # If valid selection found.
      -p {max(@{-1,3}-@{-1,0},@{-1,4}-@{-1,1})}                                          # Compute max dimension of selected rectangle.
      -if {~-1<5} -_x_mandelbrot_coords $1 -rm[1] -_x_mandelbrot_palette -mv[-1] 1   # If selection too small, reset the view,
      -else ({@{0,0}+@{-1,0}*(@{0,2}-@{0,0})/~-3};\                                  # Else compute new fractal coordinates.
             {@{0,1}+@{-1,1}*(@{0,3}-@{0,1})/~-2};\
             {@{0,0}+(@{-1,0}+~-1)*(@{0,2}-@{0,0})/~-3};\
             {@{0,1}+(@{-1,1}+~-1)*(@{0,3}-@{0,1})/~-2})
      -endif
      -pp[-1] -rm[0] -mv[-1] 0                                                  # Validate new coordinates.
    -endif
    -rm[-1]                                                                     # Delete latest rendering.
    -if {@{!,C}}                                                                # If 'C' key has been pressed.
      -if $1 -v + -e[0--4] "Julia set, at c = ("@{0,0-1}")-("@{0,2-3}"), with c0 = ($2,$3)." -v -
      -else -v + -e[0--4] "Mandelbrot set, at c = ("@{0,0-1}")-("@{0,2-3}")." -v -
      -endif
    -endif
    -pp[-3--1]
    -if {!@!" || "@{!,ESC}" || "@{!,Q}} -rm -w 0 -v + -return -endif
    -wait -1
  -while 1

_x_mandelbrot_coords :
  -if $1 (-2;-2;2;2) -else (-2.1;-1.5;1.2;1.5) -endif

_x_mandelbrot_palette :
  6,1,1,3 -rand[-1] 20,255 -r[-1] 32,1,1,3,3 -r[-1] 1024,1,1,3,0,2 -=[-1] 0,0,0,0,0 -=[-1] 0,0,0,0,1 -=[-1] 0,0,0,0,2

#@gmic x_fish_eye : : Launch fish-eye demo.
x_fish_eye :
  -e[] "\n
------ Fish-eye demo --------------------\n
----\n
---- Mouse pointer moves fish-eye center.\n
---- Mouse buttons set fish-eye size.\n
---- Keys 'ESC' or 'Q' to exit.\n
----\n
-----------------------------------------"

  -v -
  -if {@#>0} -a x -n 0,255 -r2dy 220 -else
  120,90,1,3 -rand[-1] 0,255 -plasma[-1] 0.3,3 -n 0,255
  -text "  G'MIC\nFISH-EYE\n  DEMO",15,13,24,1,255 -resize2x -blur 5 -sharpen 1000
  -f i+150-4*abs(y-h/2) -c[-1] 0,255 -frame_fuzzy[-1] 15,10,15,1.5,0 -to_rgb[-1]
  -endif
  -torus3d 20,6 -col3d[-1] {?(30,255)},{?(30,255)},{?(30,255)} --rot3d[-1] 1,0,0,90
  -col3d[-1] {?(30,255)},{?(30,255)},{?(30,255)} -+3d[-1] 15 -+3d[-2,-1] -db3d 0 -c3d[-1]
  -p[0] 30
  -w[-2] {2*@{-2,w}},{2*@{-2,h}},0,0,"Fish-Eye Demo"
  -repeat 100000
    -wait 40
    -if {@{!,b}==1} -pr[0] {min(80,~0+8)} -endif
    -if {@{!,b}==2} -pr[0] {max(3,~0-8)} -endif
    --object3d[-2] [-1],{50+30*cos(@{>,-1}/20)}%,{50+30*sin(@{>,-1}/31)}%,{50+330*sin(@{>,-1}/19)},0.7,0 -rot3d[-2] 1,0.2,0.6,3
    -if {@{!,x}>=0}
    -fish_eye[-1] {@{!,x}*100/@{!,w}},{@{!,y}*100/@{!,h}},~0
    -endif
    -w[-1] -rm[-1]
    -if {@!==0" || "@{!,ESC}" || "@{!,Q}} -rm[-2,-1] -pp[0] -w 0 -v + -return -endif
    -if {(@{!,CTRLLEFT}" || "@{!,CTRLRIGHT})" && "@{!,D}} -w[] {round(@{!,w}*1.5)},{round(@{!,h}*1.5)} -wait -1 -endif
    -if {(@{!,CTRLLEFT}" || "@{!,CTRLRIGHT})" && "@{!,C}} -w[] {round(@{!,w}/1.5)},{round(@{!,h}/1.5)} -wait -1 -endif
    -if {(@{!,CTRLLEFT}" || "@{!,CTRLRIGHT})" && "@{!,R}} -w[] @{0,w},@{0,h} -wait -1 -endif
  -done

#@gmic x_spline : : Launch spline curve ditor.
x_spline :
  -e[] "\n
------ Spline curve editor --------------------------\n
----\n
---- Mouse to insert/move/delete points.\n
---- Key 'R' to reset the curve.\n
---- Key 'SPACE' to shows/hide spline curve.\n
---- Key 'P' to shows/hide control points.\n
---- Key 'ENTER' to shows/hide control polygon.\n
---- Key 'T' to shows/hide point tangents.\n
---- Key 'I' to shows/hide point indices.\n
---- Key 'C' to shows/hide point coordinates.\n
---- Keys '+' and '-' to increase/decrease roundness.\n
---- Keys 'ESC' or 'Q' to exit.\n
----\n
-----------------------------------------------------"

  # Init display and variables.
  -v -
  -if @# -a x -n 0,255 -to_rgb -else (0;0^0;128^0;0) -r[-1] 512,512,1,3,3 -name[-1] "Spline Editor" -endif
  -w[0] @{0,w},@{0,h},0,0,@{-1,n} -r[0] @{!,w},@{!,h},1,3,1
  -i[1] 1 # Point coordinates
  -p 0.5  # Stack[-4] : Curve sharpness
  -p 23   # Stack[-3] : Visualisation flags
  -p -1   # Stack[-2] : Nearest point
  -p -1   # Stack[-1] : Active point

  # Start event loop.
  -do

    # Init coordinates [1] if necessary.
    -if {@{1,#}==1}
      -rm[1] -pr[-4] 0.5 -pr[-2] -1 -pr[-1] -1
      -i[1] ({0.2*@{-1,w}},{0.2*@{-1,h}};\
             {0.2*@{-1,w}},{0.8*@{-1,h}};\
             {0.8*@{-1,w}},{0.8*@{-1,h}};\
             {0.8*@{-1,w}},{0.2*@{-1,h}})
    -endif

    # Estimate screen-normalized coordinates [2], curve tangents [3] and tangent orientations [4].
    [1] ({@{!,w}/@{0,w}},{@{!,h}/@{0,h}}) -*[-2,-1]                       # Normalized coordinates.
    --shift[2] 0,-1,0,0,2 --shift[2] 0,1,0,0,2 --[-2,-1] -*[-1] ~-4   # Curve tangents.
    --s[-1] x -sqr[-2,-1] -+[-2,-1] -sqrt[-1] -r[-1] 2 --/[-2,-1] -rm[-2] # Tangent orientations.

    # Display curve, control points, polygon and tangents.
    --r[0] @{!,w},@{!,h},1,3
    -if {~-3&4} -polygon[-1] @{2,h},@2,0.3,128,200,255 -endif
    -repeat @{1,h}
      -line[-1] @{2,0-3},0.3,255,255,0
      -if {~-3&1} -spline[-1] @{2,0-1},@{3,0-1},@{2,2-3},@{3,2-3},1,255 -endif
      -if {~-3&8} -line[-1] {@{2,0}-@{4,0}*20},{@{2,1}-@{4,1}*20},{@{2,0}+@{4,0}*20},{@{2,1}+@{4,1}*20},1,0,255,0 -endif
      -if {~-3&16} -text[-1] @{>,-1},{@{2,0}-3},{@{2,1}-18},13,1,255,255,0 -endif
      -if {~-3&32} -text[-1] "("{round(@{1,0})}","{round(@{1,1})}")",{@{2,0}-16},{@{2,1}+10},13,1,100,200,255 -endif
      -shift[1-4] 0,-1,0,0,2
    -done
    -if {~-3&2} -repeat @{1,h}
      -ellipse[-1] @{2,0-1},4,4,0,1,0,0,0 -ellipse[-1] @{2,0-1},2,2,0,1,255,100,155 -shift[2] 0,1,0,0,2
    -done -endif
    -w[-1] -rm[3,4,-1] -wait

    # Handle key events.
    -if @{!,SPACE} -pr[-3] {~-3+if(~-3&1,-1,1)} -wait -1 -endif  # Show/hide spline.
    -if @{!,P} -pr[-3] {~-3+if(~-3&2,-2,2)} -wait -1 -endif      # Show/hide points.
    -if @{!,ENTER} -pr[-3] {~-3+if(~-3&4,-4,4)} -wait -1 -endif  # Show/hide polygon.
    -if @{!,T} -pr[-3] {~-3+if(~-3&8,-8,8)} -wait -1 -endif      # Show/hide tangents.
    -if @{!,I} -pr[-3] {~-3+if(~-3&16,-16,16)} -wait -1 -endif   # Show/hide indices.
    -if {@{!,C}" && "!@{!,CTRLLEFT}" && "!@{!,CTRLRIGHT}} -pr[-3] {~-3+if(~-3&32,-32,32)} -wait -1 -endif # Show/hide coordinates.
    -if {@{!,PADADD}" && "~-4<1} -pr[-4] {~-4*1.1} -wait -1 -endif       # Increase roundness.
    -if {@{!,PADSUB}" && "~-4>0.1} -pr[-4] {~-4*0.9} -wait -1 -endif     # Decrease roundness.
    -if {@{!,R}" && "!@{!,CTRLLEFT}" && "!@{!,CTRLRIGHT}} -rm[-1] -i[1] 1 -wait -1 -endif # Reset curve.
    -if {(@{!,CTRLLEFT}" || "@{!,CTRLRIGHT})" && "@{!,D}} -w[] {round(@{!,w}*1.5)},{round(@{!,h}*1.5)} -endif # Increase window size.
    -if {(@{!,CTRLLEFT}" || "@{!,CTRLRIGHT})" && "@{!,C}} -w[] {round(@{!,w}/1.5)},{round(@{!,h}/1.5)} -endif # Decrease window size.
    -if {(@{!,CTRLLEFT}" || "@{!,CTRLRIGHT})" && "@{!,R}} -w[] @{0,w},@{0,h} -endif                           # Reset window size.
    -if @{!,r} -w[] -endif # Resize window if necessary.

    # Set/unset active point.
    -if {@{!,b}==0} -pr[-1] -1                                      # Unset active point if mouse button is released.
    -elif {@{!,x}>=0" && "@{!,b}" && "~-1==-1}                  # Find new active point.
      [2] (@{!,x},@{!,y}) --[-2,-1] -sqr[-1] -s[-1] x -+[-2,-1]     # Compute distance vector to points.
      (@{-1,c}) -pr[-2] @{-1,1} -rm[-1]                             # Set nearest point.
      -if {@{-1,m}<64} -pr[-1] ~-2 -endif                       # Set it as active point, if near enough.
      -rm[-1]
    -endif
    -rm[2]

    # Move active point.
    -if {@{!,b}&1" && "@{!,x}>=0" && "~-1!=-1}
      -=[1] {@{!,x}*@{0,w}/@{!,w}},0,~-1
      -=[1] {@{!,y}*@{0,h}/@{!,h}},1,~-1

    # Delete nearest point.
    -elif {@{!,b}&2" && "@{!,x}>=0" && "@{1,h}>3}
      -l[1] -s y -rm[~-2] -a y -endl -wait -1

    # Insert new active point.
    -elif {@{!,b}&1" && "@{!,x}>=0}
      -p ({@{!,x}*@{0,w}/@{!,w}},{@{!,y}*@{0,h}/@{!,h}})              # Point coordinates in the image basis.
      --shift[1] 0,-1,0,0,2 -+[-1] [1] -/[-1] 2                       # Compute center of segments.
      ~-1 --[-2,-1] -sqr[-1] -s[-1] x -+[-2,-1]                   # Compute distance vector to segments.
      (@{-1,c}) -p @{-1,1} -rm[-2,-1]                                 # Push nearest segment.
      -l[1] -s y -i[{~-1+1}] ~-2 -a y -endl                   # Insert new point at right position.
      -p {~-1+1} -pp[-4--2]                                       # Set new active point as newly inserted.
    -endif

  -while {@!" && "!@{!,ESC}" && "!@{!,Q}}

  # Render spline as a tertiary mask for output.
  --shift[1] 0,-1,0,0,2 --shift[1] 0,1,0,0,2 --[-2,-1] -*[-1] ~-4
  [0],[0],1,1,2 -rm[0]
  -repeat @{1,h} -spline[-1] @{0,0-1},@{1,0-1},@{0,2-3},@{1,2-3},1,1 -shift[0] 0,-1,0,0,2 -shift[1] 0,-1,0,0,2 -done
  -flood[-1] 0,0,0,0,1,0

  # Exit properly.
  -pp[-4--1] -rm[0,1] -w 0 -v +

#@gmic x_tictactoe : : Launch tic-tac-toe game.
x_tictactoe :
  -e[] "\n
------ Tic-Tac-Toe game -----------------\n
----\n
---- Use mouse to select positions of the\n
---- symbols. Close window to exit game.\n
----\n
-----------------------------------------"
  -v -                            # Become quiet.

  # Allocate variables.
  -p 0                            # [-7] : State message.
  -p 0                            # [-6] : Turn counter (0 to 8).
  -p 0                            # [-5] : Current player (0 or 1).
  -p 0                            # [-4] : Board state.
  -p 0                            # [-3] : Temporary variable 3.
  -p 0                            # [-2] : Temporary variable 2.
  -p 0                            # [-1] : Temporary variable 1.
  -_x_tictactoe2                  # Generate board.
  -w[-1] -1,-1,0,0," "            # Init display window.

  # Start main loop.
  -do

    # Set state message depending on the current player.
    -if ~-5 -pr[-7] "Tic-Tac-Toe (O to play)"
    -else -pr[-7] "Tic-Tac-Toe (X to play)"
    -endif

    # Select position by the user.
    -do                                                                       # Enter event loop.
      -w[] @{-1,w},@{-1,h},0,0,~-7 -wait                                        # Wait for events and force window size if necessary.
      -if {!@!} -pp[-7--1] -w[] 0 -v + -return -endif                           # Quit properly if window has been closed.
      -if {@{!,b}&1" && "@{!,x}>20" && "@{!,y}>20" && "@{!,x}<400" && "@{!,y}<400} # If mouse button has been pressed on the board area.
        -pr[-3] {((@{!,x}-15)/130)>>0}                                          # Get x-coord of the selected position (0,1 or 2).
        -pr[-2] {((@{!,y}-15)/130)>>0}                                          # Get y-coord of the selected position (0,1 or 2).
        -pr[-1] {4^(~-2*3+~-3)}                                                 # Get state code of the selected position.
        -if {((~-4/~-1)>>0)%4} -pr[-1] -1 -endif                                # Check availability of the selected position.
      -else -pr[-1] -1 -endif                                                   # If no mouse button, do nothing but loop.
    -while {~-1<0}                                                            # Go on until a valid position has been selected.

    # Draw symbol on selected position and update board state.
    -_x_tictactoe{~-5%2}                                                      # Generate the symbol sprite and his mask.
    -image[-3] [-2],{"130*"~-3" + 15+?(-5,5)"},\                              # Draw symbol at its position (with some fuzzyness).
                    {"130*"~-2" + 15+?(-5,5)"},0,0,1,[-1]
    -rm[-2--1]                                                                # Delete the sprite and the mask (not needed anymore).
    -w[-1]                                                                    # Update display window.
    -pr[-4] {~-4+(1+~-5)*~-1}                                                 # Update the board state.

    # Check for a winning configuration.
    (21,1344,86016,4161,16644,66576,65793,4368;\                              # The list of winning configurations.
     0,0,0,0,1,2,0,0;\                                                        # Corresponding X coords for the stroke.
     0,1,2,0,0,0,0,0;\                                                        # Corresponding Y coords for the stroke.
     3,3,3,4,4,4,5,6)                                                         # Corresponding indice of the stroke sprite.
    -repeat @{-1,w}                                                           # Start to check configurations.
      -pr[-1] @{-1,@{>,-1}}                                                     # Save the current configuration code (used several times).
      -if {(~-4&~-1)==~-1||(~-4&(2*~-1))==2*~-1}                                # If a winner has been found.
        -_x_tictactoe@{-1,(@{>,-1},3)}                                            # Generate the stroke symbol and his mask.
        -image[-4] [-2],{130*@{-3,(@{>,-1},1)}+?(-5,5)},\                         # And display it on the board at its position.
                        {130*@{-3,(@{>,-1},2)}+?(-5,5)},0,0,1,[-1] -rm[-2--1]
        -if {(~-4&~-1)==~-1} -w[-2] -1,-1,0,0,"Tic-Tac-Toe (X won !)"
        -else -w[-2] -1,-1,0,0,"Tic-Tac-Toe (O won !)"                            # Update display window.
        -endif
        -do -wait -w[] @{!,w},@{!,h} -while @!                                    # Wait for the window to be closed.
        -rm[-1] -pp[-7--1] -w[-1] 0 -v + -return                                  # And return properly.
      -endif
    -done                                                                     # Go on until all configurations have been checked.
    -rm[-1]                                                                   # Delete winning configuration data.

    -pr[-5] {(~-5+1)%2}                                                     # Select next player.
    -pr[-6] {~-6+1}                                                         # Increment turn counter.
  -while {~-6<9}                                                            # Loop to next move until all positions have been filled.

  # Here, the game has been ended without winners.
  -w[] -1,-1,0,0,"Tic-Tac-Toe (Tied game !)"                                # Change window title.
  -do -wait -w[] @{!,w},@{!,h} -while @!                                    # Wait for the window to be closed.
  -pp[-7--1] -w[] 0 -v +                                                    # Return properly.

# Generate Tic-Tac-Toe graphics.
_x_tictactoe : # Apply a hand-drawing effect.
  -spread[-1] 4 -blur[-1] 6 -sharpen[-1] 0.8 -n[-1] 0,1

__x_tictactoe : # Apply color to last image and generate corresponding opacity mask.
  --f[-1] 1-i --n[-2] $2,255 --n[-3] $3,255 -n[-4] $1,255 -a[-4,-2,-1] c

_x_tictactoe0 : # Generate a 'X' and his mask.
  128,128,1,1,1 -line[-1] 15%,15%,85%,85%,1,0 -line[-1] 15%,85%,85%,15%,1,0 -erode[-1] 12 -_x_tictactoe -deform[-1] 4 -__x_tictactoe 40,40,160

_x_tictactoe1 : # Generate a 'O' and his mask.
  128,128,1,1,1 -ellipse[-1] 50%,50%,22%,22%,0,1,0 -ellipse[-1] 50%,50%,15%,15%,0,1,1 -_x_tictactoe -deform[-1] 4 -__x_tictactoe 160,40,160

_x_tictactoe2 : # Generate the board.
  391,391,1,1,"!(x%130) || !(y%130)" -r[-1] 421,421,1,1,0,0,0.5,0.5 -dilate[-1] 3 -_x_tictactoe -f[-1] 1-i
  100%,100% -noise[-1] 10 -blur[-1] 8,0 -sharpen[-1] 1.5 -n[-1] 220,255 -*[-2,-1] -to_rgb[-1]

_x_tictactoe3 : # Generate an horizontal stroke and his mask.
  421,130,1,1,1 -line[-1] 10%,60%,90%,60%,1,0 -erode[-1] 6 -_x_tictactoe -rotate[-1] {?(-6,6)},1,1,50%,50% -__x_tictactoe 180,10,10

_x_tictactoe4 : # Generate a vertical stroke and his mask.
  -_x_tictactoe3 -transpose[-2--1]

_x_tictactoe5 : # Generate a ++ diagonal stroke and his mask.
  421,421,1,1,1 -line[-1] 10%,10%,90%,90%,1,0 -erode[-1] 6 -_x_tictactoe -__x_tictactoe 180,10,10

_x_tictactoe6 : # Generate a +- diagonal stroke and his mask.
  421,421,1,1,1 -line[-1] 10%,90%,90%,10%,1,0 -erode[-1] 6 -_x_tictactoe -__x_tictactoe 180,10,10

#@gmic x_fourier : : Launch Fourier filtering demo.
x_fourier :
  -e[] "\n
------ Fourier-filtering demo -----------------------------------\n
----\n
---- Mouse buttons on the right image to set min/max frequencies.\n
---- Keys 'ESC' or 'Q' to exit.\n
----\n
-----------------------------------------------------------------"

  -if {!@#} -e[] "\n No images have been specified. At least one image is required.\n" -return -endif
  -v -
  -repeat @# -l[@{>,-1}]

    # Init variables.
    -p[0] 1               # need_update (boolean)
    -p[1] 0               # min freq. (in %)
    -p[2] 100             # max freq. (in %)

    -if {2*@{-1,w}>3*@{!,u}/5} -r2dx[-1] {3*@{!,u}/10} -endif  # Reduce image size if necessary.
    -if {@{-1,h}>3*@{!,v}/5} -r2dy[-1] {3*@{!,v}/5} -endif

    # Compute Fourier transform.
    --fft[-1]

    # Generate log-magnitude image.
    --sqr[-2,-1] -+[-2,-1] -sqrt[-1] -+[-1] 1 -log[-1] -to_colormode @{-2,s} -n[-1] 0,255 -shift[-1] 50%,50%,0,0,2

    # Enter user event-loop.
    -do

      -if ~0 # If image must be updated.

        # Generated filtering mask.
        100%,100%
        -p {(sqrt(@{-1,w}^2+@{-1,h}^2)*~2/200)>>0} -ellipse[-1] 50%,50%,~-1,~-1,0,1,1 -pp[-1]
        -p {max(0,((sqrt(@{-1,w}^2+@{-1,h}^2)*~1/200)>>0)-1)} -ellipse[-1] 50%,50%,~-1,~-1,0,1,0 -pp[-1]

        # Compute filtered log-magnitude.
        --*[-2] [-1] -+[-1] [-3] -/[-1] 2

        # Compute filtered fourier representation.
        -shift[-2] -{@{-1,w}/2},-{@{-1,h}/2},0,0,2
        --*[-5,-4] [-2]
        -rm[-4]

        # Compute filtered image by inverse Fourier.
        -ifft[5,6] -rm[-1] -n[-1] 0,255

        # Display filtered image.
        -reverse[-2,-1]
        -if @! -r[-2,-1] {@{!,w}/2},@{!,h} -endif
        -text[-1] "Freq. Min/Max = "{~1>>0}"% / "{~2>>0}"%",5,5,13,1,255
        -w[-2,-1] -1,-1,0,0,"Fourier Filtering Demo"
        -rm[-2,-1]
        -pr[0] 0

      -endif

      -wait

      -if {@{!,b}" && "@{!,x}>=@{!,w}/2}  # If mouse button pressed on the right pane.
        -p {200*sqrt((@{!,x}-3*@{!,w}/4)^2+(@{!,y}-@{!,h}/2)^2)/\ # Compute selected radius (in %).
            sqrt((@{!,w}/2)^2+@{!,h}^2)}
        -if {@{!,b}&1} -pr[2] ~-1                       # Update max freq. if left button.
        -else -pr[1] {max(0,~-1-3)}                     # Update min freq. if other button.
        -endif
        -pp[-1]
        -if {~1>=~2} -pr[1] ~2 -endif                   # Check that the min/max freq. are ordered.
        -pr[0] 1                                        # Tell that the image must be updated.
      -endif

      -if @{!,r} -pr[0] 1 -endif
      -if {(@{!,CTRLLEFT}" || "@{!,CTRLRIGHT})" && "@{!,D}} -w[] {round(@{!,w}*1.5)},{round(@{!,h}*1.5)} -pr[0] 1 -endif # Increase window size.
      -if {(@{!,CTRLLEFT}" || "@{!,CTRLRIGHT})" && "@{!,C}} -w[] {round(@{!,w}/1.5)},{round(@{!,h}/1.5)} -pr[0] 1 -endif # Decrease window size.
      -if {(@{!,CTRLLEFT}" || "@{!,CTRLRIGHT})" && "@{!,R}} -w[] {2*@{0,w}},@{0,h} -pr[0] 1 -endif                       # Reset window size.

    -while {@!" && "!@{!,ESC}" && "!@{!,Q}}
    -pp[0-2]    # Clean global stack.
    -rm[-3--1]  # Clean images.
  -endl -done -w 0 -v +

#@gmic x_life : : Launch the Life Game.
x_life :
  -e[] "\n
------ The game of life --------------------------------------\n
----\n
---- The goal is to create the biggest possible biological\n
---- system. You start with a stock of cells which you can\n
---- spread over the board. For each new cells created\n
---- simultaneously and spontaneously by your system, you\n
---- gain more new cells to scatter.\n
----\n
---- Left mouse button to scatter cells in stock.\n
---- Right mouse button to reset game.\n
---- Key 'S' to save snapshot of the current view.\n
---- Keys 'ESC' or 'Q' to exit.\n
----\n
--------------------------------------------------------------"
  -v -
  -i[0] 90,90,1,1,0                                             # Image[0] = game state.
  -i[1] [0] -f[1] 0                                             # Image[1] = generation counter.
  -i[2] 400,400,1,3                                             # Image[2] = visualization.
  -i[3] 1                                                       # Image[3] = colormap (to be initialized).
  -p[0] 0                                                       # Stack[0] = Iteration counter.
  -p[1] 0                                                       # Stack[1] = Current score.
  -p[2] 0                                                       # Stack[2] = Best score.
  -p[3] 500                                                     # Stack[3] = Remaining cells.
  -w[0] 400,400,0,0,"The Game of Life"                          # Initialize display window.

  # Start user-event loop.
  -do
    (1,1,1;1,0,1;1,1,1) --correlate[0] [-1],0 -rm[-2]           # Count numbers of neighboring living cells.
    --t2[-1] 2,2.1 -and[-1] [0] -t2[-2] 3,3.1 -or[-2,-1]        # Make the game evolve (kill or create cells).
    -reverse[0,-1]                                              # Update game state.
    -if {@{!,x}>0" && "@{!,b}==1" && "~3>0}                     # Add random cells to the game if user presses mouse button.
      -p {(?*7)>>0}
      -repeat ~-1
        -p {@{!,x}/@{!,w}*@{0,w}+?(-4,4)}
        -p {@{!,y}/@{!,h}*@{0,h}+?(-3,3)}
        -=[0] 1,~-2,~-1
        -=[1] ~0,~-2,~-1
        -point[2] {~-2*@{2,w}/@{0,w}},{~-1*@{2,h}/@{0,h}},0,0.8,255
        -pp[-2,-1]
      -done
      -pr[3] {max(0,~3-~-1)} -pp[-1]
    -endif

    --[-1] [0] -*[-1] -1                                        # Compute difference between consecutive states.
    -pr[3] {~3-2*((min(0,@{-1,+}/16)*~1/150)>>0)}               # Increment available cells if the evolution is fast.
    -+[1] [0]                                                   # Increment generation counter for still existing cells.
    -min[-1] 0 -+[-1] 1 -*[1,-1]                                # Reset generation counter for died cells.

    -if {@{!,b}==2}                                             # Reset game if right mouse button has been pressed.
      -f[0-2] 0 -pr[0-2] 0 -pr[3] 500 -rm[3] -i[3] 1
    -endif

    -if {@{3,w}==1}                                             # Create color palette if necessary.
      -rm[3] -i[3] {?(3,12)>>0},1,1,3,?(100,255)
      -r[3] {?(100,300)}%,1,1,3,4
      -point[3] 0,0,0,1,0
      -r[3] {?(100,600)}%,1,1,3,5
    -endif

    --r[1] @{2,w},@{2,h} -and[-1] 7 -blur[-1] {1+~1*0.05}       # Render colored image of the game and display it.
    -n[-1] 0,@{3,w} -map[-1] [3] -*[-1] 0.1 -+[2,-1] -/[2] 1.1
    [2] -if {@{!,x}>0}                                          # Add a small target icon at the mouse position.
      -p {0.7*min(1,~3/500)} -p {min(500,~3)*cos(~0)/100}
      -ellipse[-1] @{!,x},@{!,y},{15+~-1},{15+~-1},0,~-2,0,196,0
      -ellipse[-1] @{!,x},@{!,y},{10+~-1},{10+~-1},0,~-2,32,64,16
      -ellipse[-1] @{!,x},@{!,y},{5+~-1},{5+~-1},0,~-2,255,230,0
      -pp[-2,-1]
    -endif
    -text[-1] "Living cells : "~1"\n"\                          # Add score description.
              "Stock : "~3"\n"\
              "Score : "~2,5,3,22,0.7,255
    -w[-1] @{!,w},@{!,h}
    -if @{!,S} -o[-1] gmic_life.png -endif                      # Save snapshot if requested.
    -rm[-1]

    -if {!(~0%10)} -pr[1] @{0,+} -pr[2] {max(~1,~2)} -endif     # Re-compute current and best scores, every 10th iterations.
    -wait 60
    -pr[0] {~0+1}
  -while {@!" && "!@{!,ESC}" && "!@{!,Q}}

  # End game and quit properly.
  -rm[0-3] -pp[0-3] -w 0 -v +

#@gmic x_fire : : Launch fire demo.
x_fire :
  -e[] "\n
------ Fire demo ------------------------\n
----\n
---- Keys 'ESC' or 'Q' to exit.\n
----\n
-----------------------------------------"
 -v -

 # Init image data.
 -i[0] 100,32 -w[0] 600,300,0,0,"Fire demo"
 -i[1] (0,255,255,255,255^0,0,255,255,255^0,0,0,128,255) -r[1] 256,1,1,3,3
 -i[2] (0,0,0;0,0,0;1,1,1;0,1,0) -*[2] 0.23
 -text3d G\'MIC,34,3,1 -mv[-1] 3 -c3d[3] -*3d[3] 5 -col3d[-1] 255,205,130 -db3d 0 -f3d 300
 100,100 -rand[-1] 0,255 -ellipse[-1] 50%,50%,5,5,0,1,300 -blur[-1] 10
 -sharpen[-1] 1000 -shrink_xy[-1] 1 -n[-1] 0,255 -to_rgb[-1] -light3d [-1] -rm[-1]

 # Start animation loop.
 -p[0] 0
 -do
   -correlate[0] [2]                                                # Apply fire effect.
   @{0,w},1 -rand[-1] 128,256 -image[0] [-1],0,{@{0,h}-1} -rm[-1]   # Add new random values at the bottom line.
   --r[0] 400,200,1,1,3 -map[-1] [1]                                # Map fire palette
   --rot3d[3] 0,1,0,~0 -m3d 5 -object3d[-2] [-1],50%,50%            # Draw 3D object.
   -*3d[-1] 0.25,0.16,1 -m3d 3 -object3d[0] [-1],50%,50%
   -rm[-1]
   -pr[0] {~0+3}                                                    # Update 3d angle.
   -w[-1] -rm[-1] -wait 40                                          # Display 3d object.
 -while {@!" && "!@{!,ESC}" && "!@{!,Q}}

 # Exit properly.
 -rm[0-2] -pp[0]
 -v +

#--------------------------
#
# Define menu entries
# for the GIMP plug-in.
#
#--------------------------

# Generate a 'no-preview' image.
gimp_no_preview :
  -if {@#>0} -k[0] -else 256,256,1,1,128 -endif
  118,50 -text[-1] "No preview\navailable",2,1,24,1,255 -r[-1] [-2],[-2],1,1,0,0,0.5,0.5 -to_colormode[-1] @{-2,s}
  (1.5,0,1.5;0,0,0;1.5,0,1.5) -r[-1] [-3],3 -*[-3,-1] -c[-2] 0,255 -or
  -skip $*

# Do not forget to ucomment this entry for a deprecated version of the G'MIC plug-in !
# #@gimp <span foreground="red"><b>UPDATE INFORMATION</b></span> : gimp_logo_en, gimp_logo_en
# #@gimp : note = note{"A <b>new version</b> of the G'MIC plug-in for GIMP is available !
# #@gimp : You are strongly encouraged to download and install this updated version, by clicking on one of the following urls :"}
# #@gimp : note = note{"\n<span foreground="purple"><u>Windows version :</u></span>"}
# #@gimp : url = link{"Download G'MIC plug-in for Windows (32 bits)","http://downloads.sourceforge.net/gmic/gmic_gimp_win32.zip"}
# #@gimp : note = note{"<b>Installation </b>: unzip the archive files and copy them into folder\n
# #@gimp :              <i>C:\\Program Files\\GIMP\\lib\\gimp\\2.0\\plug-ins\</i>"}
# #@gimp : note = note{"\n<span foreground="purple"><u>Linux version :</u></span>"}
# #@gimp : url = link{"Download plug-in for Linux (32 bits)","http://downloads.sourceforge.net/gmic/gmic_gimp_linux32.zip"}
# #@gimp : url = link{"Download plug-in for Linux (64 bits)","http://downloads.sourceforge.net/gmic/gmic_gimp_linux64.zip"}
# #@gimp : note = note{"<b>Installation </b>: unzip the archive files and copy them in folder\n
# #@gimp :              <i>/usr/lib/gimp/2.0/plug-ins/</i>"}
# #@gimp : note = note{"\nNote that there will be no updated filters anymore for your current plug-in version.
# #@gimp : Installing the G'MIC plug-in for GIMP is easy and fast, so there are no reasons not for doing it :).\n\n
# #@gimp : Best regards,\n\n <i>The G'MIC team.</i>"}


#----------------------
# English translations
#----------------------

#@gimp_en <i>About</i>
#----------------------

#@gimp_en G'MIC for GIMP : _none_, gimp_logo_en
#@gimp_en : note = note{"
#@gimp_en : <span foreground="purple">( <b>G</b>REYC's <b>M</b>agic <b>I</b>mage <b>C</b>onverter )</span>\n\nis proposed to you by"}
#@gimp_en : note = link("David Tschumperl\303\251","http://www.greyc.ensicaen.fr/~dtschump")
#@gimp_en : note = link{"( IMAGE Team / GREYC Laboratory - CNRS UMR 6072 )","http://www.greyc.ensicaen.fr/EquipeImage"}
#@gimp_en : note = note{"
#@gimp_en : This plug-in is based on our open-source libraries <b>G'MIC</b> and <b>CImg</b> (C++ Template Image Processing Library),
#@gimp_en : available at :"}
#@gimp_en : note = link("http://gmic.sourceforge.net/")
#@gimp_en : note = note{"and"}
#@gimp_en : note = link("http://cimg.sourceforge.net/")
#@gimp_en : note = note{"\n
#@gimp_en : If you appreciate <b>G'MIC</b>, you are welcome to send us a nice postcard from your place, at :\n\n
#@gimp_en : <small><tt>David Tschumperl&#233;,\n Laboratoire GREYC (CNRS UMR 6072), Equipe Image,\n
#@gimp_en :  6 Bd du Mar&#233;chal Juin,\n 14050 Caen Cedex / France.</tt></small>\n\n
#@gimp_en : Postcards senders automatically enter the <i>Friends Hall of Fame</i> :) !
#@gimp_en : "}
gimp_logo :
-rm 118,44,1,1 -text "G'MIC",3,-6,57,1,255 -r 100%,100%,10,1 -r 100%,100%,20,1,0,0,0.5,0.5,0.5 -blur 1.5
  -isosurface3d 50%
  -col3d {?(150,255)},{?(150,255)},{?(150,255)}
  -sphere3d 8 -col3d[-1] {?(150,255)},{?(150,255)},{?(150,255)} -+3d[-1] 72,-6 -+3d -c3d[-1] -r3d
  -db3d 0 -m3d 4 -sl3d 0.2 -ss3d 1.3 -rot3d[-1] 1,0,0,30 -f3d 120 -*3d[-1] 1.5
  230,120,1,3 -object3d[-1] [-2],50%,30%,0,1 -rm[-2] -text "$1",12%,75%,24,1,255

gimp_logo_en :
  -gimp_logo "Plug-in for GIMP"

#@gimp_en Filters design : _none_, _none_
#@gimp_en : note = note{"
#@gimp_en : <b>G'MIC</b> is an <b>open</b> image processing framework. Thus, including
#@gimp_en : <b>user-defined filters</b> into this plug-in is possible.\n\n
#@gimp_en : To do so, you need to create a <span foreground="purple" style="italic">.gmic</span>
#@gimp_en : file (do not forget the first dot !) in your <i>Home</i> folder (or <i>Applications Data/</i> on Windows).
#@gimp_en : It will be read each time the plug-in is launched, or when the <i>Refresh</i>
#@gimp_en : button (under the central pane) is pressed. It must be a regular ASCII file, containing the declarations and
#@gimp_en : implementations of the filters (written in the <b>G'MIC</b> language) that will be added
#@gimp_en : to the list of available ones.\n\n
#@gimp_en : Existing filters are already defined this way.
#@gimp_en : The current implementations can be seen at :"}
#@gimp_en : note = link("http://gmic.sourceforge.net/gmic_def.xxxx")
#@gimp_en : note = note{"
#@gimp_en : Writting a new filter in <b>G'MIC</b> is not particularly awful (nor trivial) and
#@gimp_en : can be generally done in very few lines.\n\n
#@gimp_en : <span foreground="purple" underline="single">Example of a valid <i>.gmic</i> entry :</span>\n\n
#@gimp_en : <tt>#@gimp My effect : my_effect, my_effect\n
#@gimp_en : #@gimp : Sigma = float(2,0,10)\n
#@gimp_en : my_effect :\n     --blur $1 -n 0,255 -xor</tt>\n\n
#@gimp_en : By the way, you are encouraged to share your nice custom filters on the dedicated forum,
#@gimp_en : for inclusion into next releases of <b>G'MIC</b> :
#@gimp_en : "}
#@gimp_en : note = link("Go to the G'MIC forum","http://sourceforge.net/projects/gmic/forums/forum/849382")

#@gimp_en Filters update : _none_, _none_
#@gimp_en : note = note{"
#@gimp_en : Thanks to its openness, <b>G'MIC</b> is able to <b>update</b> his list of filters
#@gimp_en : from the Internet. Pushing the <i>Refresh</i> button (under the center pane)
#@gimp_en : makes <b>G'MIC</b> connect to the update server and download the latest filter definitions.
#@gimp_en : This is actually the only network operation allowed in <b>G'MIC</b>.\n\n
#@gimp_en : Technically speaking, this update procedure creates/replaces the file
#@gimp_en : <span foreground="purple" style="italic">.gmic_def.xxxx</span> in your <i>Home</i> folder
#@gimp_en : (or <i>Application Data/</i> on Windows),
#@gimp_en : where <i>xxxx</i> are the four digits of the <b>G'MIC</b> version number.
#@gimp_en : In case of connecting troubles, you can then manually do the update by retrieving the filter
#@gimp_en : definition file directly from :"}
#@gimp_en : note = link("http://gmic.sourceforge.net/gmic_def.xxxx")
#@gimp_en : note = note{"
#@gimp_en : Just copy and rename this file as your <span foreground="purple" style="italic">.gmic_def.xxxx</span>
#@gimp_en : (do not forget the first dot, and replace the <i>xxxx</i> by your <b>G'MIC</b> version number)
#@gimp_en : and you are done.
#@gimp_en : By the way, deleting this file resets all the filters to their initial state.
#@gimp_en : "}

#---------------------
# French translations
#---------------------

#@gimp_fr <i>&#192; propos</i>
#------------------------------

#@gimp_fr G'MIC pour GIMP : _none_, gimp_logo_fr
#@gimp_fr : note = note{"
#@gimp_fr : <span foreground="purple">( <b>G</b>REYC's <b>M</b>agic <b>I</b>mage <b>C</b>onverter )</span>\n\nvous est propos par"}
#@gimp_fr : note = link("David Tschumperl\303\251","http://www.greyc.ensicaen.fr/~dtschump")
#@gimp_fr : note = link{"( Equipe IMAGE / Laboratoire GREYC - CNRS UMR 6072 )","http://www.greyc.ensicaen.fr/EquipeImage"}
#@gimp_fr : note = note{"
#@gimp_fr : Ce greffon est bas&#233; sur nos biblioth&#232;ques libres <b>G'MIC</b> et <b>CImg</b> (C++ Template Image Processing Library),
#@gimp_fr : disponibles aux adresses :"}
#@gimp_fr : note = link("http://gmic.sourceforge.net/")
#@gimp_fr : note = note{"et"}
#@gimp_fr : note = link("http://cimg.sourceforge.net/")
#@gimp_fr : note = note{"\n
#@gimp_fr : Si vous appr&#233;ciez <b>G'MIC</b>, vous pouvez nous le faire savoir en nous envoyant une jolie carte
#@gimp_fr : postale de votre ville ou r&#233;gion, &#224; l'adresse :\n\n
#@gimp_fr : <small><tt>David Tschumperl&#233;,\n Laboratoire GREYC (CNRS UMR 6072), Equipe Image,\n
#@gimp_fr :  6 Bd du Mar&#233;chal Juin,\n 14050 Caen Cedex / France.</tt></small>\n\n
#@gimp_fr : Envoyer une carte postale vous fera rentrer <i>de facto</i> dans le <i>Friends Hall of Fame</i> :) !
#@gimp_fr : "}
gimp_logo_fr :
  -gimp_logo "Greffon pour GIMP"

#@gimp_fr Cr&#233;ation de filtres : _none_, _none_
#@gimp_fr : note = note{"
#@gimp_fr : <b>G'MIC</b> est un systme <b>ouvert</b> de traitement d'image. Il est ainsi possible
#@gimp_fr : d'ajouter vos <b>propres filtres personnaliss</b>  l'intrieur mme de ce greffon.\n\n
#@gimp_fr : Pour cela, il vous suffit de cr&#233;er un fichier <span foreground="purple" style="italic">.gmic</span>
#@gimp_fr : (ne pas oublier le premier point !) dans votre dossier <i>Home</i> (ou <i>Applications Data/</i> sous Windows).
#@gimp_fr : Ce fichier va tre lu &#224; chaque d&#233;marrage du greffon, ou lorsque le bouton <i>Actualiser</i>
#@gimp_fr : (sous le panneau central) sera cliqu&#233;. Ce fichier ASCII va contenir les dclarations et les
#@gimp_fr : implmentations des filtres (crits en langage <b>G'MIC</b>) qui vont s'ajouter  la liste des filtres disponibles.\n\n
#@gimp_fr : Tous les filtres existants sont dj dfinis de cette faon. Les impl&#233;mentations actuelles sont visibles
#@gimp_fr : &#224; l'adresse :"}
#@gimp_fr : note = link("http://gmic.sourceforge.net/gmic_def.xxxx")
#@gimp_fr : note = note{"
#@gimp_fr : Ecrire un filtre en langage <b>G'MIC</b> n'est pas particulirement difficile (sans tre trivial),
#@gimp_fr : et ne n&#233;cessite souvent que quelques lignes.\n\n
#@gimp_fr : <span foreground="purple" underline="single">Exemple de fichier <i>.gmic</i> valide :</span>\n\n
#@gimp_fr : <tt>#@gimp My effect : my_effect, my_effect, Sigma = float(2,0,10)\n
#@gimp_fr : my_effect :\n     --blur $1 -n 0,255 -xor</tt>\n\n
#@gimp_fr : Vous &#234;tes bien s&#251;r encourag&#233;s &#224; partager vos propres filtres sur le forum pr&#233;vu &#224;
#@gimp_fr : cet effet, pour une inclusion ventuelle dans les prochaines versions de <b>G'MIC</b> :
#@gimp_fr : "}
#@gimp_fr : note = link("Participer au forum G'MIC","http://sourceforge.net/projects/gmic/forums/forum/849382")

#@gimp_fr Mise &#224; jour des filtres : _none_, _none_
#@gimp_fr : note = note{"
#@gimp_fr : De par son architecture ouverte, <b>G'MIC</b> est capable de <b>mettre &#224; jour</b> sa liste
#@gimp_fr : de filtres. L'appui sur le bouton <i>Actualiser</i> (sous le panneau central)
#@gimp_fr : va permettre la connexion au serveur de mises &#224; jour, et le t&#233;l&#233;chargement
#@gimp_fr : des derni&#232;res d&#233;finitions de filtres. C'est la seule op&#233;ration r&#233;seau
#@gimp_fr : que nous avons autoris&#233;e dans <b>G'MIC</b>.\n\n
#@gimp_fr : Techniquement, cette proc&#233;dure cr&#233;&#233;/remplace le fichier
#@gimp_fr : <span foreground="purple" style="italic">.gmic_def.xxxx</span> dans votre r&#233;pertoire <i>Home</i>
#@gimp_fr : (ou <i>Application Data/</i> sous Windows),
#@gimp_fr : o&#249; <i>xxxx</i> sont les quatres chiffres du num&#233;ro de version du greffon <b>G'MIC</b>.
#@gimp_fr : En cas de probl&#232;me, vous pouvez donc toujours mettre &#224; jour vos filtres manuellement,
#@gimp_fr : en t&#233;l&#233;chargeant le fichier suivant :"}
#@gimp_fr : note = link("http://gmic.sourceforge.net/gmic_def.xxxx")
#@gimp_fr : note = note{"
#@gimp_fr : Copiez juste ce fichier &#224; la bonne place, et renommez le en <span foreground="purple" style="italic">.gmic_def.xxxx</span>
#@gimp_fr : (n'oubliez pas le premier point, et remplacez les <i>xxxx</i> par le num&#233;ro de version de votre greffon <b>G'MIC</b>)
#@gimp_fr : et la proc&#233;dure de mise &#224; jour sera effectu&#233;e.
#@gimp_fr : Bien entendu, effacer ce fichier rinitialise l'ensemble des d&#233;finitions des filtres &#224; leurs &#233;tats initiaux.
#@gimp_fr : "}

#----------------------
# Catalan translations
#----------------------

#@gimp_ca <i>About</i>
#----------------------

#@gimp_ca G'MIC per al GIMP : _none_, gimp_logo_ca
#@gimp_ca : note = note{"
#@gimp_ca : <span foreground="purple">( <b>G</b>REYC's <b>M</b>agic <b>I</b>mage <b>C</b>onverter )</span>\n\n &#233;s una gentilesa de"}
#@gimp_ca : note = link("David Tschumperl\303\251","http://www.greyc.ensicaen.fr/~dtschump")
#@gimp_ca : note = link{"( IMAGE Team / GREYC Laboratory - CNRS UMR 6072 )","http://www.greyc.ensicaen.fr/EquipeImage"}
#@gimp_ca : note = note{"
#@gimp_ca : Aquest connector est&#224; basat en les biblioteques de codi obert <b>G'MIC</b> i <b>CImg</b> (C++ Template Image Processing Library),
#@gimp_ca : disponibles a :"}
#@gimp_ca : note = link("http://gmic.sourceforge.net/")
#@gimp_ca : note = note{"i"}
#@gimp_ca : note = link("http://cimg.sourceforge.net/")
#@gimp_ca : note = note{"\n
#@gimp_ca : Si t'agrada el <b>G'MIC</b>, pots enviar-nos una postal del lloc on vius, a :\n\n
#@gimp_ca : <small><tt>David Tschumperl&#233;,\n Laboratoire GREYC (CNRS UMR 6072), Equipe Image,\n
#@gimp_ca :  6 Bd du Mar&#233;chal Juin,\n 14050 Caen Cedex / France.</tt></small>\n\n
#@gimp_ca : Tot aquell que envi&#239; una postal apareixer&#224; al <i>Friends Hall of Fame</i> :) !
#@gimp_ca : "}
gimp_logo_ca :
  -gimp_logo "  per al GIMP"

#@gimp_ca Filters design : _none_, _none_
#@gimp_ca : note = note{"
#@gimp_ca : Si voleu podeu afegir els vostres <b>filtres d'usuari</b> al connector <b>G'MIC</b> :\n\n
#@gimp_ca : Per a fer-ho, cal que creeu un fitxer <span foreground="purple" style="italic">.gmic</span> (no oblideu el primer punt !)
#@gimp_ca : a la vostra <i>Carpeta d'inici</i> (o a la carpeta <i>Application Data</i> al Windows).
#@gimp_ca : El connector el llegir&#224; cada vegada que s'arranqui, o quan premeu el bot&#243; <i>Actualitzar els filtres</i>.
#@gimp_ca : Aquest fitxer ha de ser un arxiu de command del <b>G'MIC</b>, i ha de contindre les definicions de filtre
#@gimp_ca : que han d'apar&#232;ixer a la llista de filtres.
#@gimp_ca : Podeu veure un exemple d'un arxiu d'aquesta mena a :"}
#@gimp_ca : note = link("http://gmic.sourceforge.net/gmic_def.xxxx")
#@gimp_ca : note = note{"
#@gimp_ca : Escriure un nou filtre amb el llenguatge <b>G'MIC</b> no &#233;s trivial del tot (per&#242; tampoc una cosa inabastable), per&#242;
#@gimp_ca : normalment es pot fer en unes quantes l&#237;nies.\n\n
#@gimp_ca : <span foreground="purple" underline="single">Example d'un fitxer <i>.gmic</i> v&#224;lid :</span>\n\n
#@gimp_ca : <tt>#@gimp My effect : my_effect, my_effect, Sigma = float(2,0,10)\n
#@gimp_ca : my_effect :\n  --blur $1 -n 0,255 -xor</tt>\n\n
#@gimp_ca : Per cert, us encoratgem a que compartiu els vostres filtres personalitzats al f&#242;rum espec&#237;fic de <b>G'MIC</b> :
#@gimp_ca : "}
#@gimp_ca : note = link("Enlla\303\247a al f\303\262rum G'MIC","http://sourceforge.net/projects/gmic/forums/forum/849382")

#@gimp_ca Filters update : _none_, _none_
#@gimp_ca : note = note{"
#@gimp_ca : El connector <b>G'MIC</b> &#233;s capa&#231; d'<b>actualitzar</b> la seva llista de definicions de filtres
#@gimp_ca : des d'Internet. Prement el bot&#243; <i>Actualitzar els filtres</i> al plaf&#243; de l'esquerra
#@gimp_ca : fa que <b>G'MIC</b> es connecti amb el servidor d'actualitzacions
#@gimp_ca : i que descarregui les darreres definicions de filtres disponibles.\n\n
#@gimp_ca : B&#224;sicament, aquest procediment crea un fitxer
#@gimp_ca : <span foreground="purple" style="italic">.gmic_def.xxxx</span> a la vostra <i>Carpeta d'inici</i>
#@gimp_ca : (o a la carpeta <i>Application Data</i> a Windows),
#@gimp_ca : on <i>xxxx</i> s&#243;n els quatre d&#237;gits de la versi&#243; del connector <b>G'MIC</b>.
#@gimp_ca : En cas que tingueu problemes, podeu actualitzar manualment els vostres filtres, baixant-vos el fitxer d'actualitzaci&#243; des de:"}
#@gimp_ca : note = link("http://gmic.sourceforge.net/gmic_def.xxxx")
#@gimp_ca : note = note{"
#@gimp_ca : Llavors, nom&#233;s cal que copieu i canvieu el nom d'aquest fitxer com a <span foreground="purple" style="italic">.gmic_def.xxxx</span>
#@gimp_ca : (no oblideu el primer punt, i substitu&#239;u <i>xxxx</i> per el n&#250;mero de versi&#243; del vostre <b>G'MIC</b>)
#@gimp_ca : i ja est&#224;!
#@gimp_ca : Per cert, si esborreu aquest fitxer, tornareu a establir les definicions de filtres originals.
#@gimp_ca : "}

#----------------------
# Untranslated filters
#----------------------

#@gimp Release notes : _none_, _none_
#@gimp : note = note{"
#@gimp : - <b>2009/01/13</b> : version <i>1.3.0.0</i> (Initial).\n
#@gimp : - <b>2009/03/18</b> : version <i>1.3.1.0</i>.\n
#@gimp : - <b>2009/08/10</b> : version <i>1.3.2.0</i>.\n
#@gimp : - <b>2009/11/23</b> : version <i>1.3.3.0</i>.\n
#@gimp : - <span foreground="purple"><b>2010/03/05</b> : version <i>1.3.4.0</i> (Current).</span>\n
#@gimp : "}

#@gimp Contributors : _none_, _none_
#@gimp : note = note{"
#@gimp : We would like to thank all these people who contributed to <b>G'MIC</b> in one way or another.
#@gimp : A big hug to : \n\n
#@gimp : <b> -</b> <i>Claude Bulin</i> <small>(packaging)</small>
#@gimp : <b> -</b> <i>J&#233;rome Ferrari</i> <small>(testing)</small>
#@gimp : <b> -</b> <i>Jalal Fadili</i> <small>(compiling)</small>
#@gimp : <b> -</b> <i>Angelo Lama</i> <small>(testing)</small>
#@gimp : <b> -</b> <i>PhotoComiX</i> <small>(testing &amp; Italian translation)</small>
#@gimp : <b> -</b> <i>Gilmoth</i> <small>(Italian translation)</small>
#@gimp : <b> -</b> <i>Stepanekos</i> <small>(German translation)</small>
#@gimp : <b> -</b> <i>Fran&#231;ois Collard</i> <small>(testing)</small>
#@gimp : <b> -</b> <i>Karsten Rodenacker</i> <small>(mac support)</small>
#@gimp : <b> -</b> <i>St&#233;phane de la Linuxerie</i> <small>(design)</small>
#@gimp : <b> -</b> <i>Dani Sard&#224;</i> <small>(Catalan translation)</small>
#@gimp : <b> -</b> <i>Mark</i> <small>(Dutch translation)</small>
#@gimp : <b> -</b> <i>Claes Holmerson</i> <small>(tutorials)</small>
#@gimp : <b> -</b> <i>The GIMP users at Flickr</i> <small>(testing and suggestions)</small>
#@gimp : <b> -</b>"}

#@gimp Friends Hall of Fame : _none_, gimp_friends
#@gimp : note = note{"\n<span foreground="purple" underline="single">Postcard senders :</span>"}
#@gimp : note = note{"    <b>-</b> <b>7</b> postcards received so far, you could be the 8th sender ! :)"}
#@gimp : note = note{" We would like to say a big thank to :"}
#@gimp : link = link("[1] Jean-Michel Webbe - Guadeloupe/France","http://cimg.sourceforge.net/img/postcard15.jpg")
#@gimp : link = link("[2] Jaime - Barcelona/Spain","http://cimg.sourceforge.net/img/postcard14.jpg")
#@gimp : link = link("[3] Institut for Biomathematik und Biometrie - Neuherberg/Germany","http://cimg.sourceforge.net/img/postcard20.jpg")
#@gimp : link = link("[4] Guy Poizat - Cabestany/France","http://cimg.sourceforge.net/img/postcard21.jpg")
#@gimp : link = link("[5] PhotoComIX - Frascati/Italy","http://cimg.sourceforge.net/img/postcard22.jpg")
#@gimp : link = link("[6] F. Albior - Jaca/Spain","http://cimg.sourceforge.net/img/postcard23.jpg")
#@gimp : link = link("[7] M???? - Munich/Germany","http://cimg.sourceforge.net/img/postcard24.jpg")
#@gimp : note = note{"\nMay the force be with you !"}
gimp_friends :
  -rm -_heart80x73 -resize3x
  --*[-1] 70 --*[-2] 40 -*[-3] 255 -a c
  -flood 0,0,0,0,1,255 -blur_radial 1.5 -whirls 7,4,1,2.79
  -text "Greetings to\n  all G'MIC\n  friends !",16,30,24,0.7,0
  -gimp_unsharp 0,0.45,0,10,0,4,4,1,0,1

_heart80x73 :
  40,73,1,1,0 -ellipse 22,22,20,20,0,1,1 -polygon 3,7,37,42,72,42,27,1,1 --mirror x -a x


#@gimp _<b>Arrays &amp; frames</b>
#----------------------------------


#@gimp Regular array : gimp_array, gimp_array_preview(1)
#@gimp : X-tiles = int(2,1,10)
#@gimp : Y-tiles = int(2,1,10)
#@gimp : X-offset = float(0,0,100)
#@gimp : Y-offset = float(0,0,100)
#@gimp : Mirror = choice("None","X-axis","Y-axis","XY-axes")
#@gimp : Size = _choice("Shrink", "Expand", "Repeat [Memory consuming !]")
gimp_array_preview :
  -gimp_array $1,$2,$3,$4,$5,0

gimp_array :
  -shift -$3%,-$4%,0,0,2
  -if {$5&1} -mirror x -endif -if {$5>1} -mirror y -endif
  -array $1,$2,$6

#@gimp Faded array : gimp_array_fade, gimp_array_fade_preview(1)
#@gimp : X-tiles = int(2,1,10)
#@gimp : Y-tiles = int(2,1,10)
#@gimp : X-offset = float(0,0,100)
#@gimp : Y-offset = float(0,0,100)
#@gimp : Fade start = float(80,1,100)
#@gimp : Fade end = float(90,1,100)
#@gimp : Mirror = choice("None","X-axis","Y-axis","XY-axes")
#@gimp : Size = _choice("Shrink", "Expand", "Repeat [Memory consuming !]")
gimp_array_fade_preview :
  -gimp_array_fade $1,$2,$3,$4,$5,$6,$7,0

gimp_array_fade :
  -if {$7&1} -mirror x -endif -if {$7>1} -mirror y -endif
  -array_fade $1,$2,$5,$6,$8
  -shift -$3%,-$4%,0,0,2

#@gimp Mirrored array : gimp_array_mirror, gimp_array_mirror_preview(1)
#@gimp : Iterations = int(1,1,10)
#@gimp : X-offset = float(0,0,100)
#@gimp : Y-offset = float(0,0,100)
#@gimp : Array mode = choice(2,"X-axis","Y-axis","XY-axes")
#@gimp : Mirror = choice("None","X-axis","Y-axis","XY-axes")
#@gimp : Expand size = _bool(false)
gimp_array_mirror_preview :
  -gimp_array_mirror $1,$2,$3,$4,$5,0

gimp_array_mirror :
  -if {$5&1} -mirror x -endif -if {$5>1} -mirror y -endif
  -array_mirror $1,$4,$5
  -shift -$2%,-$3%,0,0,2

#@gimp Random array : array_random, array_random(1)
#@gimp : Source X-tiles = int(5,1,20)
#@gimp : Source Y-tiles = int(5,1,20)
#@gimp : Destination X-tiles = int(7,1,20)
#@gimp : Destination Y-tiles = int(7,1,20)

#@gimp Random color array : gimp_array_color, gimp_array_color(1)
#@gimp : X-tiles = int(5,1,20)
#@gimp : Y-tiles = int(5,1,20)
#@gimp : Opacity = float(0.5,0,1)
gimp_array_color :
  -repeat @# -l[-1]
    $1,$2,1,3 -rand[-1] 0,255 -to_colormode[-1] @{-2,s} -r[-1] [-2] -*[-1] $3 -*[-2] {1-$3} -+[-2,-1]
  -endl -mv[-1] 0 -done

#@gimp Tiled rotation : gimp_rotate_tiles, gimp_rotate_tiles(1)
#@gimp : X-tiles = int(5,1,80)
#@gimp : Y-tiles = int(5,1,80)
#@gimp : Angle = float(15,0,360)
#@gimp : Opacity = float(1,0,1)
gimp_rotate_tiles :
  -to_rgba -rotate_tiles $3,$1,$2
  -if {$4<1} -repeat @# -s[-1] c -*[-1] $4 -a[-4--1] c -mv[-1] 0 -done -endif

#@gimp Tiled normalization : gimp_normalize_tiles, gimp_normalize_tiles(1)
#@gimp : X-tiles = int(25,1,80)
#@gimp : Y-tiles = int(25,1,80)
#@gimp : Minimal value = float(0,0,255)
#@gimp : Maximal value = float(255,0,255)
gimp_normalize_tiles :
  -repeat @# -l[-1] -split_tiles $1,$2 -n $3,$4 -append_tiles $1,$2 -endl -mv[-1] 0 -done

#@gimp Tiled random shift : gimp_shift_tiles, gimp_shift_tiles(1)
#@gimp : X-tiles = int(10,1,30)
#@gimp : Y-tiles = int(10,1,30)
#@gimp : Amplitude = float(10,0,100)
#@gimp : Opacity = float(1,0,1)
gimp_shift_tiles :
  -to_rgba -shift_tiles $1,$2,$3
  -if {$4<1} -repeat @# -s[-1] c -*[-1] $4 -a[-4--1] c -mv[-1] 0 -done -endif

#@gimp Tiled linearization : gimp_linearize_tiles, gimp_linearize_tiles(1)
#@gimp : X-tiles = int(10,1,30)
#@gimp : Y-tiles = int(10,1,30)
gimp_linearize_tiles :
  -linearize_tiles $1,$2 -cut 0,255

#@gimp Image grid : gimp_grid, gimp_grid(0)
#@gimp : X-size = int(10,2,100)
#@gimp : Y-size = int(10,2,100)
gimp_grid :
  -to_rgba -grid $1,$2

#@gimp Taquin puzzle : taquin, taquin(1)
#@gimp : X-tiles = int(7,1,20)
#@gimp : Y-tiles = int(7,1,20)

#@gimp Random pattern : gimp_array_pattern, gimp_array_pattern_preview(1)
#@gimp : X-tiles = int(10,1,30)
#@gimp : Y-tiles = int(10,1,30)
#@gimp : Density = float(80,0,100)
#@gimp : Angle = float(180,0,180)
#@gimp : Zoom = float(30,0,100)
#@gimp : Opacity = float(1,0,1)
#@gimp : Image size = _choice("Shrink", "Expand", "Repeat [Memory consuming !]")
gimp_array_pattern :
  -to_rgba -array_pattern $1,$2,$3,$4,$5,$6,0

gimp_array_pattern_preview :
  -to_rgba -array_pattern $1,$2,$3,$4,$5,$6,$7

#@gimp Regular frame : gimp_frame, gimp_frame(1)
#@gimp : Width = int(10,0,100)
#@gimp : Height = int(10,0,100)
#@gimp : Color = color(255,255,255,0)
gimp_frame :
  -repeat @#
    ({@{-1,w}*$1/100},{@{-1,h}*$2/100}) -round[-1] 1
    -frame[-2] @-1,$3,$4,$5,$6 -rm[-1]
  -mv[-1] 0 -done

#@gimp Fuzzy frame : gimp_frame_fuzzy, gimp_frame_fuzzy(0)
#@gimp : Width = int(10,0,99)
#@gimp : Height = int(10,0,99)
#@gimp : Fuzzyness = float(10,0,40)
#@gimp : Smoothness = float(1,0,5)
#@gimp : Color = color(255,255,255,0)
gimp_frame_fuzzy :
  -repeat @#
    ({@{-1,w}*$1/200},{@{-1,h}*$2/200}) -round[-1] 1
    -frame_fuzzy[-2] @-1,$3,$4,$5,$6,$7,$8 -rm[-1]
  -mv[-1] 0 -done

#@gimp Round frame : frame_round, frame_round(1)
#@gimp : Sharpness = float(6,0.1,20)
#@gimp : Size = float(20,0,100)
#@gimp : Smoothness = float(0.1,0,5)
#@gimp : Color = color(255,255,255,0)


#@gimp _<b>Artistic</b>
#-----------------------


#@gimp Polaroid : gimp_polaroid, gimp_polaroid(1)
#@gimp : Frame size = int(10,1,400)
#@gimp : Bottom size = int(20,1,400)
#@gimp : X-shadow = float(0,-20,20)
#@gimp : Y-shadow = float(0,-20,20)
#@gimp : Smoothness = float(3,0,5)
#@gimp : Angle = float(20,0,360)
gimp_polaroid :
  -polaroid $1,$2 -drop_shadow $3%,$4%,$5% -rotate $6,0

#@gimp Old photograph : old_photo, old_photo(1)

#@gimp Drop shadow : gimp_drop_shadow, gimp_drop_shadow(1)
#@gimp : X-shadow = float(3,-20,20)
#@gimp : Y-shadow = float(3,-20,20)
#@gimp : Smoothness = float(1.8,0,5)
#@gimp : Angle = float(0,0,360)
gimp_drop_shadow :
  -drop_shadow $1%,$2%,$3% -rotate $4,0

#@gimp Reflection : gimp_reflect, gimp_reflect(1)
#@gimp : Height = float(50,0,100)
#@gimp : Attenuation = float(1,0.1,4)
#@gimp : Color = color(110,160,190,64)
#@gimp : Waves amplitude = float(0,0,100)
#@gimp : Waves smoothness = float(1.5,0,4)
#@gimp : X-angle = float(0,-10,10)
#@gimp : Y-angle = float(-3.30,-10,10)
#@gimp : Focale = float(7,0,10)
#@gimp : Zoom = float(1.5,1,5)
gimp_reflect :
  -repeat @#
    -to_rgba[-1] --lines[-1] {100-$1}%,100% -mirror[-1] y -water[-1] $7,$8
    -s[-1] c
    -f[-4] "(i*(255-$6) + $6*$3)/255"
    -f[-3] "(i*(255-$6) + $6*$4)/255"
    -f[-2] "(i*(255-$6) + $6*$5)/255" -a[-4--1] c
    -*[-1] '(h^$2-y^$2)/h^$2' -a[-2,-1] y
    100%,100%,100%,1,$11*$12*(x/w-0.5)
    100%,100%,100%,1,$11*$12*(y/h-0.5)
    100%,100%,100%,1,"$10*(x/w-0.5) + $9*(y/h-0.5) + $11"
    -/[-3] [-1] -+[-3] 0.5 -*[-3] @{-3,w}
    -/[-2,-1] -+[-1] 0.5 -*[-1] @{-1,h}
    -a[-2,-1] c -warp[-2] [-1],0,1,0 -rm[-1]
  -mv[-1] 0 -done
  -autocrop 0,0,0,0

#@gimp Random color ellipses : gimp_color_ellipses, gimp_color_ellipses(1)
#@gimp : Density = int(400,0,3000)
#@gimp : Radius = float(8,0,30)
#@gimp : Opacity = float(0.1,0.01,0.5)
gimp_color_ellipses :
  -to_rgb -color_ellipses $1,$2,$3

#@gimp Cartoon : cartoon, cartoon(0)
#@gimp : Smoothness = float(2,0,10)
#@gimp : Sharpening = float(200,0,400)
#@gimp : Edge threshold = float(10,1,30)
#@gimp : Edge thickness = float(0.25,0,1)
#@gimp : Color strength = float(1.5,0,3)
#@gimp : Color quantization = int(32,2,256)

#@gimp Pen drawing : gimp_pen_drawing, gimp_pen_drawing(0)
#@gimp : Amplitude = float(10,0,30)
gimp_pen_drawing :
  -to_rgb -drawing $1

#@gimp Whirl drawing : draw_whirl, draw_whirl(0)
#@gimp : Amplitude = float(20,0,100)

#@gimp Cubism : cubism, cubism(1)
#@gimp : Iterations = int(300,1,2000)
#@gimp : Bloc size = float(10,0,40)
#@gimp : Angle = float(90,0,360)
#@gimp : Opacity = float(0.7,0.01,1)
#@gimp : Smoothness = float(0,0,5)

#@gimp Kaleidoscope : gimp_kaleidoscope, gimp_kaleidoscope(1)
#@gimp : X-center = float(0.5,0,1)
#@gimp : Y-center = float(0.5,0,1)
#@gimp : X-offset = float(0,0,100)
#@gimp : Y-offset = float(0,0,100)
#@gimp : Radius cut = float(100,0,100)
#@gimp : Angle cut = float(10,0,100)
#@gimp : Borders = choice(2,"Black","Nearest","Repeat")
gimp_kaleidoscope :
  -shift $3%,$4%,0,0,2 -kaleidoscope $1,$2,$5,$6,$7

#@gimp Stencil : gimp_stencil, gimp_stencil(0)
#@gimp : Amplitude = int(5,1,10)
#@gimp : Sharpness = float(10,0,100)
#@gimp : Radius = float(3,0,10)
#@gimp : Channel(s) = choice(3,"All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","AB-components","A-component","B-component","Hue","Saturation","Value","Key","Alpha")
gimp_stencil :
  -apply_channels "-repeat $1 -blur $3 -unsharp $3,$2 -c 0,255 -mv[-1] 0 -done",$4,0

#@gimp B&amp;W stencil : stencilbw, stencilbw(0)
#@gimp : Threshold = float(10,0,30)
#@gimp : Smoothness = float(10,0,30)

#@gimp B&amp;W pencil : pencilbw, pencilbw(0)
#@gimp : Size = float(0.3,0,5)
#@gimp : Amplitude = float(60,0,200)

#@gimp B&amp;W dots : dotsbw, gimp_dotsbw_preview(1)
gimp_dotsbw_preview :
  -r 300%,300%,1,3,3 -dotsbw

#@gimp Warhol : warhol, warhol(1)
#@gimp : X-tiles = int(3,1,10)
#@gimp : Y-tiles = int(3,1,10)
#@gimp : Smoothness = float(2,0,10)
#@gimp : Color = float(40,0,60)

#@gimp Soft glow : glow, glow(1)
#@gimp : Amplitude = float(1,0,8)

#@gimp Tetris effect : gimp_tetris, gimp_tetris(0)
#@gimp : Scale = int(10,1,20)
gimp_tetris :
  -to_rgb -tetris $1


#@gimp _<b>Colors</b>
#---------------------


#@gimp RGB mixer : gimp_mix_rgb, gimp_mix_rgb(1)
#@gimp : Red gain = float(1,0,4)
#@gimp : Red offset = float(0,-255,255)
#@gimp : Red smoothness = float(0,0,10)
#@gimp : Green gain = float(1,0,4)
#@gimp : Green offset = float(0,-255,255)
#@gimp : Green smoothness = float(0,0,10)
#@gimp : Blue gain = float(1,0,4)
#@gimp : Blue offset = float(0,-255,255)
#@gimp : Blue smoothness = float(0,0,10)
#@gimp : note = note()
#@gimp : Tones range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gimp : Tones smoothness = float(2,0,10)
gimp_start_mix :
  -if {$1==1} --tones[-1] 3 -+[-2,-1] -blur[-2,-1] $2% -r[-2,-1] [-3] -*[-1] [-3] -mv[-3] @#
  -elif {$1==2} --tones[-1] 3 -+[-3,-1] -blur[-2,-1] $2% -r[-2,-1] [-3] -*[-2] [-3] -mv[-3] @#
  -elif {$1==3} --tones[-1] 3 -+[-3,-2] -blur[-2,-1] $2% -r[-2,-1] [-3] -*[-2] [-3] -mv[-3] @#
  -endif
gimp_end_mix :
  -if {$1==1} -*[-3,-1] -+[-2,-1]
  -elif {$1==2} -*[-2,-1] -+[-2,-1]
  -elif {$1==3} -*[-2,-1] -+[-2,-1]
  -endif

gimp_mix_rgb :
  -repeat @# -l[-1] -split_opacity -reverse -to_rgb[-1]
    -gimp_start_mix $10,$11
    --[-1] 128 -s[-1] c
    -*[-3] $1 -+[-3] $2 -blur[-3] $3%
    -*[-2] $4 -+[-2] $5 -blur[-2] $6%
    -*[-1] $7 -+[-1] $8 -blur[-1] $9%
    -a[-3--1] c -+[-1] 128 -c[-1] 0,255
    -gimp_end_mix $10
  -if {@#!=3} -reverse -a c -endif -endl -mv[-1] 0 -done

#@gimp YCbCr mixer : gimp_mix_ycbcr, gimp_mix_ycbcr(1)
#@gimp : Luminance gain = float(1,0,4)
#@gimp : Luminance offset = float(0,-255,255)
#@gimp : Luminance smoothness = float(0,0,10)
#@gimp : Blue chroma gain = float(1,0,4)
#@gimp : Blue chroma offset = float(0,-255,255)
#@gimp : Blue chroma smoothness = float(0,0,10)
#@gimp : Red chroma gain = float(1,0,4)
#@gimp : Red chroma offset = float(0,-255,255)
#@gimp : Red chroma smoothness = float(0,0,10)
#@gimp : note = note()
#@gimp : Tones range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gimp : Tones smoothness = float(2,0,10)
gimp_mix_ycbcr :
  -repeat @# -l[-1] -split_opacity -reverse -to_rgb[-1]
    -gimp_start_mix $10,$11
    -rgb2ycbcr[-1] --[-1] 128 -s[-1] c
    -*[-3] $1 -+[-3] $2 -blur[-3] $3%
    -*[-2] $4 -+[-2] $5 -blur[-2] $6%
    -*[-1] $7 -+[-1] $8 -blur[-1] $9%
    -a[-3--1] c -+[-1] 128 -c[-1] 0,255 -ycbcr2rgb[-1]
    -gimp_end_mix $10
  -if {@#!=3} -reverse -a c -endif -endl -mv[-1] 0 -done

#@gimp HSV mixer : gimp_mix_hsv, gimp_mix_hsv(1)
#@gimp : Hue gain = float(1,0,4)
#@gimp : Hue offset = float(0,-180,180)
#@gimp : Hue smoothness = float(0,0,10)
#@gimp : Saturation gain = float(1,0,4)
#@gimp : Saturation offset = float(0,-1,1)
#@gimp : Saturation smoothness = float(0,0,10)
#@gimp : Value gain = float(1,0,4)
#@gimp : Value offset = float(0,-1,1)
#@gimp : Value smoothness = float(0,0,10)
#@gimp : note = note()
#@gimp : Tones range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gimp : Tones smoothness = float(2,0,10)
gimp_mix_hsv :
  -repeat @# -l[-1] -split_opacity -reverse -to_rgb[-1]
    -gimp_start_mix $10,$11
    -rgb2hsv[-1] -s[-1] c --[-2,-1] 0.5
    -*[-3] $1 -+[-3] $2 -blur[-3] $3%
    -*[-2] $4 -+[-2] $5 -blur[-2] $6%
    -*[-1] $7 -+[-1] $8 -blur[-1] $9%
    -mod[-3] 360 -+[-2,-1] 0.5 -c[-2,-1] 0,1 -a[-3--1] c -hsv2rgb[-1]
    -gimp_end_mix $10
  -if {@#!=3} -reverse -a c -endif -endl -mv[-1] 0 -done

#@gimp Lab mixer : gimp_mix_lab, gimp_mix_lab(1)
#@gimp : Lightness gain = float(1,0.5,1.5)
#@gimp : Lightness offset = float(0,-50,50)
#@gimp : Lightness smoothness = float(0,0,10)
#@gimp : A-color gain = float(1,0,4)
#@gimp : A-color offset = float(0,-20,20)
#@gimp : A-color smoothness = float(0,0,10)
#@gimp : B-color gain = float(1,0,4)
#@gimp : B-color offset = float(0,-20,20)
#@gimp : B-color smoothness = float(0,0,10)
#@gimp : note = note()
#@gimp : Tones range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gimp : Tones smoothness = float(2,0,10)
gimp_mix_lab :
  -repeat @# -l[-1] -split_opacity -reverse -to_rgb[-1]
    -gimp_start_mix $10,$11
    -rgb2lab[-1] -s[-1] c
    -*[-3] $1 -+[-3] $2 -blur[-3] $3%
    -*[-2] $4 -+[-2] $5 -blur[-2] $6%
    -*[-1] $7 -+[-1] $8 -blur[-1] $9%
    -a[-3--1] c -lab2rgb[-1]
    -gimp_end_mix $10
  -if {@#!=3} -reverse -a c -endif -endl -mv[-1] 0 -done

#@gimp CMYK mixer : gimp_mix_cmyk, gimp_mix_cmyk(1)
#@gimp : Cyan gain = float(1,0,4)
#@gimp : Cyan offset = float(0,-255,255)
#@gimp : Cyan smoothness = float(0,0,10)
#@gimp : Magenta gain = float(1,0,4)
#@gimp : Magenta offset = float(0,-255,255)
#@gimp : Magenta smoothness = float(0,0,10)
#@gimp : Yellow gain = float(1,0,4)
#@gimp : Yellow offset = float(0,-255,255)
#@gimp : Yellow smoothness = float(0,0,10)
#@gimp : Key gain = float(1,0,4)
#@gimp : Key offset = float(0,-255,255)
#@gimp : Key smoothness = float(0,0,10)
#@gimp : note = note()
#@gimp : Tones range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gimp : Tones smoothness = float(2,0,10)
gimp_mix_cmyk :
  -repeat @# -l[-1] -split_opacity -reverse -to_rgb[-1]
    -gimp_start_mix $13,$14
    -rgb2cmyk[-1] -s[-1] c
    -*[-4] $1 -+[-4] $2 -blur[-4] $3%
    -*[-3] $4 -+[-3] $5 -blur[-3] $6%
    -*[-2] $7 -+[-2] $8 -blur[-2] $9%
    -*[-1] $10 -+[-1] $11 -blur[-1] $12%
    -a[-4--1] c -cmyk2rgb[-1]
    -gimp_end_mix $13
  -if {@#!=3} -reverse -a c -endif -endl -mv[-1] 0 -done

#@gimp Channel processing : gimp_channel_processing, gimp_channel_processing(1)
#@gimp : Gamma = float(1,0.01,5)
#@gimp : Gain = float(1,0,4)
#@gimp : Offset = float(0,-255,255)
#@gimp : Smoothness = float(0,0,10)
#@gimp : Value action = choice("None","Cut","Cut & Normalize","Normalize","Threshold")
#@gimp : Low value = float(0,0,100)
#@gimp : High value = float(100,0,100)
#@gimp : Quantization = int(256,1,256)
#@gimp : Equalization = bool()
#@gimp : Negation = bool()
#@gimp : note = note()
#@gimp : Tones range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gimp : Tones smoothness = float(2,0,10)
#@gimp : note = note()
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","AB-components","A-component","B-component","Hue","Saturation","Value","Key","Alpha")
gimp_channel_processing : # -skip ${1=1},${2=1},${3=0},${4=0},${5=0},${6=0},${7=0},${8=256},${9=0},${10=0},${11=0},${12=2},${13=0}
  -repeat @# -l[-1] -split_opacity -reverse -to_rgb[-1]
    -gimp_start_mix $11,$12
    -apply_channels[-1] "-_gimp_channel_processing $1,$2,$3,$4,$5,$6,$7,$8,$9,$10",$13,0
    -gimp_end_mix $11
  -if {@#!=3} -reverse -a c -endif -endl -mv[-1] 0 -done

_gimp_channel_processing :
  -apply_gamma[-1] $1
  -if {$2!=1} --[-1] 128 -*[-1] $2 -+[-1] 128 -endif
  -+[-1] $3
  -blur[-1] $4% -c[-1] 0,255
  -if {$5==1} -c[-1] $6%,$7%
  -elif {$5==2} -c[-1] $6%,$7% -n[-1] 0,255
  -elif {$5==3} -n[-1] $6%,$7%
  -elif {$5==4} -t2[-1] $6%,$7% -*[-1] 255
  -endif
  -if {$8!=256} -quantize[-1] $8 -endif
  -if $9 -equalize[-1] 256 -endif
  -if $10 -negative[-1] -endif

#@gimp Local normalization : gimp_normalize_local, gimp_normalize_local(0)
#@gimp : Amplitude = float(3,0,60)
#@gimp : Radius = int(24,1,512)
#@gimp : Neighborhood smoothness = float(4,0,40)
#@gimp : Average smoothness = float(2,0,40)
#@gimp : Constraint values = bool(1)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","AB-components","A-component","B-component","Hue","Saturation","Value","Key","Alpha")
gimp_normalize_local :
  -apply_channels "-normalize_local $1,$2,$3,$4,$5,0,255",$6,0

#@gimp Black &amp; White : gimp_blackandwhite, gimp_blackandwhite(1)
#@gimp : Red level = float(0.299,0,1)
#@gimp : Red smoothness = float(0,0,10)
#@gimp : Green level = float(0.587,0,1)
#@gimp : Green smoothness = float(0,0,10)
#@gimp : Blue level = float(0.114,0,1)
#@gimp : Blue smoothness = float(0,0,10)
#@gimp : note = note()
#@gimp : Gamma = float(1,0.01,5)
#@gimp : Gain = float(1,0,4)
#@gimp : Offset = float(0,-255,255)
#@gimp : note = note()
#@gimp : Grain (shadows) = float(0,0,200)
#@gimp : Grain (midtones) = float(0,0,200)
#@gimp : Grain (highlights) = float(0,0,200)
#@gimp : Grain tone fading = float(2,0,10)
#@gimp : Grain scale = float(0,0,3)
#@gimp : Grain type = choice("Gaussian","Uniform","Salt and pepper","Poisson")
#@gimp : note = note()
#@gimp : Local contrast = float(0,0,60)
#@gimp : Radius = int(16,1,512)
#@gimp : Contrast smoothness = float(4,0,10)
gimp_blackandwhite :
  -repeat @#
    -l[-1] -split_opacity -reverse -to_rgb[-1] -s[-1] c     # Isolate opacity
    -*[-3] $1 -blur[-3] $2%                                 # Red gain + smoothness
    -*[-2] $3 -blur[-2] $4%                                 # Green gain + smoothness
    -*[-1] $5 -blur[-1] $6%                                 # Blue gain + smoothness
    -+[-3--1] -/[-1] {$1+$3+$5} -c[-1] 0,255                # (R,G,B) -> B&W
    -apply_gamma[-1] $7                                     # Gamma correction
    --[-1] 128 -*[-1] $8 -+[-1] 128 -+[-1] $9 -c[-1] 0,255  # B&W gain and offset.

    100%,100% [-1]x2                                        # Create noise for shadows, midtones and highlights.
    -noise[-3] 100,$15 -blur[-3] $14% -n[-3] -$10,$10       # Scaled grain on shadows.
    -noise[-2] 100,$15 -blur[-2] $14% -n[-2] -$11,$11       # Scaled grain on midtones.
    -noise[-1] 100,$15 -blur[-1] $14% -n[-1] -$12,$12       # Scaled grain on highlights.

    --tones[-4] 3 -blur[-3--1] $13%                         # Get smoothed tones.
    -*[-6,-3] -*[-4,-2] -*[-2,-1]                           # Get noisy tones.
    -+[-4--1] -c[-1] 0,255                                  # Compose them with the B&W image.

    -reverse -a c -endl -mv[-1] 0 -done                     # Re-compose opacity and loop to next image.
  -normalize_local $16,$17,$18,2%,1,0,255

#@gimp Sepia : gimp_sepia, gimp_sepia
#@gimp : Gamma = float(1,0.01,5)
#@gimp : Gain = float(1,0,4)
#@gimp : Offset = float(0,-255,255)
gimp_sepia :
  -sepia -apply_gamma[-1] $1 -- 128 -* $2 -+ 128 -+ $3 -c 0,255

#@gimp B&amp;W dithering : gimp_ditheredbw, gimp_ditheredbw(0)
#@gimp : Gamma = float(1,0.01,5)
#@gimp : Gain = float(1,0,4)
#@gimp : Offset = float(0,-255,255)
#@gimp : Smoothness = float(0,0,10)
gimp_ditheredbw :
  -apply_gamma[-1] $1 -- 128 -* $2 -+ 128 -+ $3 -blur $4 -c 0,255 -ditheredbw

#@gimp Select color : gimp_select_color, gimp_select_color(1)
#@gimp : Similarity space = choice(0,"RGB[A]","RGB","YCbCr","Red","Green","Blue","Opacity","Luminance","Blue & Red chrominances","Hue","Saturation")
#@gimp : Tolerance = float(20,0,100)
#@gimp : Smoothness = float(0,0,10)
#@gimp : "Selected color    " = color(255,255,255,255)
#@gimp : Output as = choice(0,"Selected colors","Selected mask")
#@gimp : Invert selection = bool(0)
_gimp_select_color :
  -if {$1==1} -to_rgb                            # RGB
  -elif {$1==2} -to_rgb -rgb2ycbcr               # YCbCr
  -elif {$1==3} -channels 0                      # R
  -elif {$1==4} -channels 1                      # G
  -elif {$1==5} -channels 2                      # B
  -elif {$1==6} -to_rgba -channels 3             # Opacity
  -elif {$1==7} -to_rgb -rgb2ycbcr -channels 0   # Luminance
  -elif {$1==8} -to_rgb -rgb2ycbcr -channels 1,2 # B&R chrominances
  -elif {$1==9} -to_rgb -rgb2hsv -channels 0     # Hue
  -elif {$1==10} -to_rgb -rgb2hsv -channels 1    # Saturation
  -endif

gimp_select_color :
  ($4^$5^$6^$7) -_gimp_select_color[-1] $1 -p @-1 -rm[-1]
  -repeat @#
    -if {$8==0}                                  # Output selected colors.
      --_gimp_select_color[-1] $1
      -select_color[-1] $2%,~-1
      -blur[-1] $3%
      -if $9 -*[-1] -1 -+[-1] 1 -endif
      -to_rgba[-2] -s[-2] c -*[-2,-1] -a[-4--1] c
    -else
      -_gimp_select_color[-1] $1
      -select_color[-1] $2%,~-1
      -blur[-1] $3
      -if $9 -*[-1] -1 -+[-1] 1 -endif
      -*[-1] 255 -r[-1] 100%,100%,1,4
    -endif
  -mv[-1] 0 -done
  -pp[-1]

#@gimp Replace color : gimp_replace_color, gimp_replace_color(1)
#@gimp : Tolerance = float(100,1,450)
#@gimp : Smoothness = float(0,0,10)
#@gimp : "Selected color    " = color(255,255,255,255)
#@gimp : "Replaced color   " = color(0,0,0,0)
gimp_replace_color :
  -to_rgba -replace_color $1,$2%,${3*} -c 0,255

#@gimp User-defined : gimp_custom_transform, gimp_custom_transform
#@gimp : Red - Green - Blue - Alpha = text{"i"}
#@gimp : Red - Green - Blue = text{"i + 90*(x/w)*cos(i/10)"}
#@gimp : Red = text{"i"}
#@gimp : Green = text{"i"}
#@gimp : Blue = text{"i"}
#@gimp : Alpha = text{"i"}
#@gimp : Value normalization = choice("None","RGB","RGBA")
gimp_custom_transform :
  -to_rgba -repeat @#
    -f[-1] "$1"
    -s[-1] c -a[-4--2] c -f[-2] "$2"
    -s[-2] c -f[-4] "$3" -f[-3] "$4" -f[-2] "$5" -f[-1] "$6"
    -if {$7==0} -a[-4--1] c -c[-1] 0,255
    -elif {$7==1} -a[-4--2] c -n[-2] 0,255 -c[-1] 0,255 -a[-2,-1] c
    -else -a[-4--1] c -n[-1] 0,255
    -endif
  -mv[-1] 0 -done

#@gimp Linear gradient : gimp_linear_gradient, gimp_linear_gradient
#@gimp : Starting color = color(0,0,0,255)
#@gimp : Ending color = color(255,255,255,255)
#@gimp : Swap colors = bool(0)
#@gimp : Angle = float(45,0,360)
#@gimp : Fade start = float(0,0,100)
#@gimp : Fade end = float(100,0,100)
gimp_linear_gradient :
  -v - -repeat @#
    (@{-1,w},@{-1,h}) -rm[-2]
    ($1^$2^$3^$4) ($5^$6^$7^$8)
    -if $9 -reverse[-2,-1] -endif
    -r[-2,-1] @-3 -rm[-3]
    -fade_linear $10,$11,$12
  -mv[-1] 0 -done -v +

#@gimp Radial gradient : gimp_radial_gradient, gimp_radial_gradient
#@gimp : Starting color = color(0,0,0,255)
#@gimp : Ending color = color(255,255,255,255)
#@gimp : Swap colors = bool(0)
#@gimp : Fade start = float(0,0,100)
#@gimp : Fade end = float(100,0,100)
#@gimp : X-center = float(50,0,100)
#@gimp : Y-center = float(50,0,100)
gimp_radial_gradient :
  -v - -repeat @#
    (@{-1,w},@{-1,h}) -rm[-2]
    ($1^$2^$3^$4) ($5^$6^$7^$8)
    -if $9 -reverse[-2,-1] -endif
    -r[-2,-1] @-3 -rm[-3]
    100%,100% -=[-1] 1,$12%,$13% -distance[-1] 1 -_fade $10,$11
  -mv[-1] 0 -done -v +

#@gimp Corner gradient : gimp_corner_gradient, gimp_corner_gradient
#@gimp : "Color 1 (up/left corner)         " = color(255,255,255,128)
#@gimp : "Color 2 (up/right corner)       " = color(255,0,0,255)
#@gimp : "Color 3 (bottom/left corner)  " = color(0,255,0,255)
#@gimp : "Color 4 (bottom/right corner)" = color(0,0,255,255)
gimp_corner_gradient :
  -repeat @#
    (@{-1,w},@{-1,h}) -rm[-2]
    ($1,$5;$9,$13^$2,$6;$10,$14^$3,$7;$11,$15^$4,$8;$12,$16) -r[-1] @-2,1,4,3 -rm[-2]
  -mv[-1] 0 -done


#@gimp _<b>Contours</b>
#----------------------

#@gimp Gradient norm : gimp_gradient_norm, gimp_gradient_norm(0)
#@gimp : Smoothness = float(0,0,10)
#@gimp : Linearity = float(0.5,0,1.5)
#@gimp : Min threshold = float(0,0,100)
#@gimp : Max threshold = float(100,0,100)
#@gimp : Negative colors = bool(0)
gimp_gradient_norm :
  -blur $1 -gradient_norm -pow $2
  -c $3%,$4%
  -if $5 -negative -endif
  -n 0,255

#@gimp Gradient as RGB : gimp_gradient2rgb, gimp_gradient2rgb(0)
#@gimp : Smoothness = float(0,0,10)
#@gimp : Min threshold = float(0,0,100)
#@gimp : Max threshold = float(100,0,100)
#@gimp : Orientation only = bool(0)
#@gimp : Negative colors = bool(0)
gimp_gradient2rgb :
  -blur $1 -gradient2rgb $4
  -c $2%,$3%
  -if $5 -negative -endif
  -n 0,255

#@gimp Local orientation : gimp_local_orientation, gimp_local_orientation(1)
#@gimp : Smoothness = float(0,0,5)
#@gimp : Min threshold = float(0,0,100)
#@gimp : Max threshold = float(100,0,100)
#@gimp : Negative colors = bool(0)
#@gimp : Channel(s) = choice(3,"All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","AB-components","A-component","B-component","Hue","Saturation","Value","Key","Alpha")
_gimp_local_orientation :
  -blur $1% -gradient_orientation 2 -complex2polar -rm[0--1:2]
  -c $2%,$3%
  -if $4 -negative -endif

gimp_local_orientation :
  -apply_channels "-_gimp_local_orientation $1,$2,$3,$4",$5,1

#@gimp Laplacian : gimp_laplacian, gimp_laplacian(0)
#@gimp : Smoothness = float(0,0,10)
#@gimp : Min threshold = float(0,0,100)
#@gimp : Max threshold = float(100,0,100)
#@gimp : Absolute value = bool(0)
#@gimp : Negative colors = bool(0)
gimp_laplacian :
  -blur $1 -laplacian
  -if $4 -abs -endif
  -c $2%,$3%
  -if $5 -negative -endif
  -n 0,255

#@gimp Curvature : gimp_curvature, gimp_curvature(0)
#@gimp : Smoothness = float(2,0,10)
#@gimp : Min threshold = float(0,0,100)
#@gimp : Max threshold = float(100,0,100)
#@gimp : Absolute value = bool(0)
#@gimp : Negative colors = bool(0)
gimp_curvature :
  -blur $1 -curvature
  -if $4 -abs -endif
  -c $2%,$3%
  -if $5 -negative -endif
  -n 0,255

#@gimp Edges : gimp_edges, gimp_edges(0)
#@gimp : Smoothness = float(0,0,10)
#@gimp : Threshold = float(10,1,40)
#@gimp : Negative colors = bool(0)
gimp_edges :
  -to_rgb -blur $1 -edges $2
  -if $3 -negative -endif
  -n 0,255

#@gimp Isophotes : gimp_isophotes, gimp_isophotes(0)
#@gimp : Levels = int(16,1,256)
#@gimp : Smoothness = float(0,0,5)
#@gimp : Filling = choice(0,"Transparent","Colors")
gimp_isophotes :
  -if $3
    -topographic_map $1,$2
  -else
    -blur $2 -isophotes $1
  -endif

#@gimp Difference of gaussians : gimp_dog, gimp_dog(1)
#@gimp : 1st Variance = float(1.4,0,5)
#@gimp : 2nd Variance = float(1.5,0,5)
#@gimp : Threshold = float(0,0,49)
#@gimp : Negative colors = bool(0)
gimp_dog :
  -dog $1%,$2%
  -c $3%,{100-$3}%
  -if $4 -negative -endif
  -n 0,255

#@gimp Morphological filter : gimp_morpho, gimp_morpho(0)
#@gimp : Action = choice("Erosion","Dilation","Opening","Closing",
#@gimp : "Original - Erosion","Dilation - Original","Original - Opening","Closing - Original")
#@gimp : Size = int(5,2,60)
#@gimp : Invert colors = bool(false)
gimp_morpho :
  -if {$1==0} -erode $2
  -elif {$1==1} -dilate $2
  -elif {$1==2} -erode $2 -dilate $2
  -elif {$1==3} -dilate $2 -erode $2
  -elif {$1==4} -repeat @# --erode $2 --[-2,-1] -n[-1] 0,255 -mv[-1] 0 -done
  -elif {$1==5} -repeat @# --dilate $2 -reverse[-2,-1] --[-2,-1] -n[-1] 0,255 -mv[-1] 0 -done
  -elif {$1==6} -repeat @# --erode $2 -dilate[-1] $2 --[-2,-1] -n[-1] 0,255 -mv[-1] 0 -done
  -else -repeat @# --dilate $2 -erode[-1] $2 -reverse[-2,-1] --[-2,-1] -n[-1] 0,255 -mv[-1] 0 -done
  -endif
  -if $3 -negative -endif


#@gimp _<b>Deformations</b>
#--------------------------


#@gimp Zoom : gimp_zoom, gimp_zoom(1)
#@gimp : Factor = float(2,0.01,10)
#@gimp : X-center = float(0.5,0,1)
#@gimp : Y-center = float(0.5,0,1)
#@gimp : Borders = choice(0,"Black","Nearest","Repeat")
gimp_zoom :
  -if {$1<1} -to_rgba -endif
  -zoom $1,$2,$3,0,$4

#@gimp Water : water, water(0)
#@gimp : Amplitude = float(30,0,300)
#@gimp : Smoothness = float(1.5,0,4)

#@gimp Wave : wave, wave(1)
#@gimp : Amplitude = float(10,0,30)
#@gimp : Frequency = float(0.4,0,2)
#@gimp : X-center = float(50,0,100)
#@gimp : Y-center = float(50,0,100)

#@gimp Twirl : twirl, twirl(1)
#@gimp : Amplitude = float(1,-5,5)
#@gimp : X-center = float(0.5,0,1)
#@gimp : Y-center = float(0.5,0,1)
#@gimp : Borders = choice(1,"Black","Nearest","Repeat")

#@gimp Flower : gimp_flower, gimp_flower(1)
#@gimp : Amplitude = float(30,-100,100)
#@gimp : Petals = int(6,0,20)
#@gimp : Offset = float(0,0,100)
#@gimp : Angle = float(0,0,360)
#@gimp : X-center = float(0.5,0,1)
#@gimp : Y-center = float(0.5,0,1)
#@gimp : Borders = choice(1,"Black","Nearest","Repeat")
gimp_flower :
  -flower $1,$2,$3%,$4,$5,$6,$7

#@gimp Random : deform, deform(0)
#@gimp : Amplitude = float(10,0,100)

#@gimp Fish-eye : fish_eye, fish_eye(1)
#@gimp : X-center = float(50,0,100)
#@gimp : Y-center = float(50,0,100)
#@gimp : Radius = float(70,0,100)
#@gimp : Amplitude = float(1,0,2)

#@gimp Sphere : gimp_map_sphere, gimp_map_sphere_preview(1)
#@gimp : Width = _int(512,1,4096)
#@gimp : Height = _int(512,1,4096)
#@gimp : Radius = float(90,0,400)
#@gimp : Dilation = float(0.5,0,1)
#@gimp : Angle = float(0,-50,50)
gimp_map_sphere :
  -shift $5%,0,0,0,2 -to_rgba -map_sphere $1,$2,$3,$4

gimp_map_sphere_preview :
  -gimp_map_sphere @{-1,w},@{-1,h},$3,$4,$5

#@gimp Perspective : gimp_warp_perspective, gimp_warp_perspective(1)
#@gimp : X-angle = float(1.73,-4,4)
#@gimp : Y-angle = float(0,-4,4)
#@gimp : Zoom = float(1,0.1,4)
#@gimp : X-center = float(50,0,100)
#@gimp : Y-center = float(50,0,100)
#@gimp : X-offset = float(0,0,100)
#@gimp : Y-offset = float(0,0,100)
#@gimp : Borders = choice(2,"Black","Nearest","Repeat")
gimp_warp_perspective :
  -shift $6%,$7%,0,0,2 -warp_perspective $1,$2,$3,$4,$5,$8

#@gimp Euclidean &#60;-&#62; Polar : gimp_euclidean2polar, gimp_euclidean2polar(1)
#@gimp : X-center = float(0.5,0,1)
#@gimp : Y-center = float(0.5,0,1)
#@gimp : Dilation = float(1,0.1,10)
#@gimp : Borders = choice(1,"Black","Nearest","Repeat")
#@gimp : Inverse transform = bool(0)
gimp_euclidean2polar :
  -if $5 -polar2euclidean $1,$2,$3,$4 -else -euclidean2polar $1,$2,$3,$4 -endif

#@gimp Cartesian custom transform : gimp_custom_deformation, gimp_custom_deformation(1)
#@gimp : X-warping = text{"(w+h)/20 * cos(y*20/h)"}
#@gimp : Y-warping = text{"(w+h)/20 * sin(x*20/w)"}
#@gimp : Relative warping = bool(1)
#@gimp : Interpolation = choice(1,"Nearest neighbor","Linear")
#@gimp : Borders = choice(1,"Black","Nearest","Repeat")
gimp_custom_deformation :
   -repeat @#
    --norm[-1] [-1] -f[-2] "$1" -f[-1] "$2"
    -a[-2,-1] c -warp[-2] [-1],$3,$4,$5,1 -rm[-1]
  -mv[-1] 0 -done

#@gimp Polar custom transform : gimp_transform_polar, gimp_transform_polar(1)
#@gimp : Preset = choice("Custom transform","Inverse radius","Swap radius/angle")
#@gimp : X-center = float(50,0,100)
#@gimp : Y-center = float(50,0,100)
#@gimp : Radius = text{"r + R/10*cos(a*5)"}
#@gimp : Angle = text{"a"}
#@gimp : Borders = choice(1,"Black","Nearest","Repeat")
gimp_transform_polar :
  -if {$1==0}
    -transform_polar "$4","$5",$2,$3,$6
  -elif {$1==1}
    -transform_polar R-r,a,$2,$3,$6
  -else
    -transform_polar a*R/(2*pi),r*2*pi/R,$2,$3,$6
  -endif


#@gimp _<b>Degradations</b>
#---------------------------


#@gimp Additive noise : gimp_noise, gimp_noise(0)
#@gimp : Amplitude = float(10,0,200)
#@gimp : Noise type = choice("Gaussian","Uniform","Salt and pepper","Poisson")
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","AB-components","A-component","B-component","Hue","Saturation","Value","Key","Alpha")
#@gimp : Value range = choice("Cut","Normalize")
gimp_noise :
  -apply_channels "-noise $1,$2",$3,$4

#@gimp Spread noise : gimp_spread, gimp_spread(0)
#@gimp : X-variations = float(4,0,20)
#@gimp : Y-variations = float(4,0,20)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","AB-components","A-component","B-component","Hue","Saturation","Value","Key","Alpha")
gimp_spread :
  -apply_channels "-spread $1,$2",$3,0

#@gimp Random shade stripes : gimp_shade_stripes, gimp_shade_stripes(1)
#@gimp : Frequency = float(30,1,100)
#@gimp : Orientation = choice(1,"Horizontal","Vertical")
#@gimp : Darkness = float(0.8,0,3)
#@gimp : Lightness = float(1.3,0,3)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","AB-components","A-component","B-component","Hue","Saturation","Value","Key","Alpha")
gimp_shade_stripes :
  -apply_channels "-shade_stripes $1,$2,$3,$4",$5,0

#@gimp Old-movie stripes : gimp_stripes_y, gimp_stripes_y(1)
#@gimp : Frequency = float(10,0,100)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","AB-components","A-component","B-component","Hue","Saturation","Value","Key","Alpha")
gimp_stripes_y :
  -apply_channels "-stripes_y $1",$2,0

#@gimp Damp patch : gimp_damp_patch, gimp_damp_patch(1)
#@gimp : Opacity = float(0.7,0,1)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","AB-components","A-component","B-component","Hue","Saturation","Value","Key","Alpha")
gimp_damp_patch :
  -apply_channels "-damp_patch $1",$2,0

#@gimp Light patch : gimp_light_patch, gimp_light_patch(0)
#@gimp : Density = int(5,2,30)
#@gimp : Darkness = float(0.7,0,1)
#@gimp : Lightness = float(2.5,1,4)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","AB-components","A-component","B-component","Hue","Saturation","Value","Key","Alpha")
gimp_light_patch :
  -apply_channels "-light_patch $1,$2,$3",$4,0

#@gimp Gaussian blur : gimp_gaussian_blur, gimp_gaussian_blur(1)
#@gimp : XY-amplitude = float(3,0,40)
#@gimp : X-amplitude = float(0,0,40)
#@gimp : Y-amplitude = float(0,0,40)
#@gimp : Border conditions = choice(1,"Black","Nearest")
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","AB-components","A-component","B-component","Hue","Saturation","Value","Key","Alpha")
#@gimp : Value range = choice("Cut","Normalize")
_gimp_gaussian_blur :
  -blur $1%,$4
  -if {$2>0} -repeat @# -l[-1] -s y -blur $2%,$4 -a y -endl -mv[-1] 0 -done -endif
  -if {$3>0} -repeat @# -l[-1] -s x -blur $3%,$4 -a x -endl -mv[-1] 0 -done -endif

gimp_gaussian_blur :
  -apply_channels "-_gimp_gaussian_blur $1,$2,$3,$4",$5,$6

#@gimp Linear blur : gimp_blur_linear, gimp_blur_linear(1)
#@gimp : Tangent amplitude = float(0.07,0.01,0.5)
#@gimp : Orthogonal amplitude = float(0.01,0.005,0.1)
#@gimp : Angle = float(0,0,180)
#@gimp : Border conditions = choice(1,"Black","Nearest")
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","AB-components","A-component","B-component","Hue","Saturation","Value","Key","Alpha")
#@gimp : Value range = choice("Cut","Normalize")
gimp_blur_linear :
  -apply_channels "-blur_linear $1,$2,$3,$4",$5,$6

#@gimp Radial blur : gimp_blur_radial, gimp_blur_radial(1)
#@gimp : Amplitude = float(3,0,20)
#@gimp : X-center = float(0.5,0,1)
#@gimp : Y-center = float(0.5,0,1)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","AB-components","A-component","B-component","Hue","Saturation","Value","Key","Alpha")
#@gimp : Value range = choice("Cut","Normalize")
gimp_blur_radial :
  -apply_channels "-blur_radial $1%,$2,$3",$4,$5

#@gimp Angular blur : gimp_blur_angular, gimp_blur_angular(1)
#@gimp : Amplitude = float(2,0,10)
#@gimp : X-center = float(0.5,0,1)
#@gimp : Y-center = float(0.5,0,1)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","AB-components","A-component","B-component","Hue","Saturation","Value","Key","Alpha")
#@gimp : Value range = choice("Cut","Normalize")
gimp_blur_angular :
  -apply_channels "-blur_angular $1%,$2,$3",$4,$5

#@gimp RGB Bayer mask : rgb2bayer, rgb2bayer(0)
#@gimp : Starting pattern = choice(0,"Red-Green","Blue-Green","Green-Red","Green-Blue")
#@gimp : Keep colors = bool(1)

#@gimp Bayer reconstruction : bayer2rgb, gimp_no_preview
#@gimp : G/M smoothness = _float(6,0,20)
#@gimp : R/B smoothness (principal) = _float(6,0,20)
#@gimp : R/B smoothness (secondary) = _float(4,0,20)


#@gimp _<b>Enhancement</b>
#--------------------------


#@gimp Anisotropic smoothing : gimp_anisotropic_smoothing, gimp_anisotropic_smoothing(0)
#@gimp : Amplitude = float(60,0,1000)
#@gimp : Sharpness = float(0.7,0,2)
#@gimp : Anisotropy = float(0.3,0,1)
#@gimp : Gradient smoothness = float(0.6,0,10)
#@gimp : Tensor smoothness = float(1.1,0,10)
#@gimp : Spatial precision = float(0.8,0.1,2)
#@gimp : Angular precision = float(30,1,180)
#@gimp : Value precision = float(2,0.1,5)
#@gimp : Interpolation = choice(0,"Nearest neighbor","Linear","Runge-Kutta")
#@gimp : Fast approximation = bool(1)
#@gimp : Iterations = int(1,1,10)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","AB-components","A-component","B-component","Hue","Saturation","Value","Key","Alpha")
#@gimp : Tiles = int(1,1,10)
gimp_anisotropic_smoothing :
  -repeat @# -l[@{>,-1}]
    -split_tiles $13,$13
    -apply_channels "-repeat $11 -smooth $1,$2,$3,$4,$5,$6,$7,$8,$9,$10 -done",$12,0
    -append_tiles $13,$13
  -endl -done -c 0,255

#@gimp Patch-based smoothing : gimp_patch_smoothing, gimp_patch_smoothing(0)
#@gimp : Spatial variance = float(10,0.1,200)
#@gimp : Patch variance = float(10,0.1,200)
#@gimp : Patch size = int(3,2,21)
#@gimp : Lookup size = int(5,2,21)
#@gimp : Patch smoothness = float(0,0,4)
#@gimp : Fast approximation = bool(1)
#@gimp : Iterations = int(1,1,10)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","AB-components","A-component","B-component","Hue","Saturation","Value","Key","Alpha")
gimp_patch_smoothing :
  -apply_channels "-repeat $7 -denoise $1,$2,$3,$4,$5,$6 -done",$8,0 -c 0,255

#@gimp Edge-preserving flow : gimp_edgepreserving_smoothing, gimp_edgepreserving_smoothing(0)
#@gimp : Sharpness = float(0.7,0,2)
#@gimp : Anisotropy = float(0.3,0,1)
#@gimp : Gradient smoothness = float(0.6,0,10)
#@gimp : Tensor smoothness = float(1.1,0,10)
#@gimp : Time step = float(15,5,50)
#@gimp : Iterations = int(8,1,100)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","AB-components","A-component","B-component","Hue","Saturation","Value","Key","Alpha")
gimp_edgepreserving_smoothing :
  -apply_channels "-smooth $6,$1,$2,$3,$4,$5,0",$7,0 -c 0,255

#@gimp Mean-curvature flow : gimp_meancurvature_smoothing, gimp_meancurvature_smoothing(0)
#@gimp : Time step = float(30,5,50)
#@gimp : Iterations = int(4,1,10)
#@gimp : Keep iterations as different layers = bool(false)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","AB-components","A-component","B-component","Hue","Saturation","Value","Key","Alpha")
gimp_meancurvature_smoothing :
  -apply_channels "-meancurvature_flow $2,$1,$3",$4,0 -c 0,255

#@gimp Total-variation flow : gimp_tv_smoothing, gimp_tv_smoothing(0)
#@gimp : Time step = float(30,5,100)
#@gimp : Iterations = int(10,1,40)
#@gimp : Keep iterations as different layers = bool(false)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","AB-components","A-component","B-component","Hue","Saturation","Value","Key","Alpha")
gimp_tv_smoothing :
  -apply_channels "-tv_flow $2,$1,$3",$4,0 -c 0,255

#@gimp Bilateral filtering : gimp_bilateral, gimp_bilateral(0)
#@gimp : Spatial variance = float(10,0,100)
#@gimp : Value variance = float(7,0,100)
#@gimp : Iterations = int(2,1,10)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","AB-components","A-component","B-component","Hue","Saturation","Value","Key","Alpha")
gimp_bilateral :
  -apply_channels "-repeat $3 -bilateral $1,$2 -done",$4,0

#@gimp Hot pixels filtering : remove_hotpixels, remove_hotpixels(0)
#@gimp : Mask size = int(3,3,20)
#@gimp : Threshold = float(10,0,200)

#@gimp Unsharp mask : gimp_unsharp, gimp_unsharp(0)
#@gimp : Sharpening type = choice(0,"Gaussian","Bilateral")
#@gimp : Spatial radius = float(1.25,0,20)
#@gimp : Bilateral radius = float(30,0,60)
#@gimp : Amount = float(3,0,10)
#@gimp : Threshold = float(0,0,20)
#@gimp : Darkness level = float(1,0,4)
#@gimp : Lightness level = float(1,0,4)
#@gimp : Iterations = int(1,1,10)
#@gimp : Negative effect = bool(0)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","AB-components","A-component","B-component","Hue","Saturation","Value","Key","Alpha")
#@gimp : note = note{"\n\n<small><b>Note : </b>
#@gimp : This filter is inspired by the original <i>Unsharp Mask</i> filter in GIMP, with additional parameters.
#@gimp : </small>"}
_gimp_unsharp :
  -repeat @# -repeat $8
    -if {$1==0} --blur[-1] $2 -else --bilateral[-1] $2,$3 -endif
    --[-1] [-2] -*[-1] -$4
    --norm[-1] -t[-1] $5% -r[-1] [-2] -*[-2,-1]
    -if $9 -*[-1] -1 -endif
    --c[-1] 0,100% -c[-2] -100%,0 -*[-2] $6 -*[-1] $7 -+[-2,-1]
    -+[-2,-1] -c[-1] 0,255
  -done -mv[-1] 0 -done

gimp_unsharp :
  -apply_channels "-_gimp_unsharp $1,$2,$3,$4,$5,$6,$7,$8,$9",$10,0

#@gimp Octave sharpening : gimp_unsharp_octave, gimp_unsharp_octave(0)
#@gimp : Scales = int(4,1,10)
#@gimp : Maximal radius = float(5,0,20)
#@gimp : Amount = float(3,0,10)
#@gimp : Threshold = float(0,0,255)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","AB-components","A-component","B-component","Hue","Saturation","Value","Key","Alpha")
gimp_unsharp_octave :
  -apply_channels "-unsharp_octave $1,$2,$3,$4",$5,0

#@gimp Inverse diffusion : gimp_sharpen_inversediff, gimp_sharpen_inversediff(0)
#@gimp : Amplitude = float(50,1,300)
#@gimp : Iterations = int(2,1,10)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","AB-components","A-component","B-component","Hue","Saturation","Value","Key","Alpha")
gimp_sharpen_inversediff :
  -apply_channels "-repeat $2 -sharpen $1,0 -c 0,255 -done",$3,0

#@gimp Shock filters : gimp_sharpen_shock, gimp_sharpen_shock(0)
#@gimp : Amplitude = float(150,1,400)
#@gimp : Edge threshold = float(0.1,0,0.7)
#@gimp : Gradient smoothness = float(0.8,0,10)
#@gimp : Tensor smoothness = float(1.1,0,10)
#@gimp : Iterations = int(1,1,10)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","AB-components","A-component","B-component","Hue","Saturation","Value","Key","Alpha")
gimp_sharpen_shock :
  -apply_channels "-repeat $5 -sharpen $1,1,$2,$3,$4 -c 0,255 -done",$6,0

#@gimp Region inpainting : gimp_inpaint, gimp_inpaint_preview(0)
#@gimp : Smooth inpaint = bool(true)
#@gimp : Global iterations = int(10,1,30)
#@gimp : Local iterations = int(10,1,30)
#@gimp : Time step = float(20,5,50)
#@gimp : Gradient smoothness = float(0.7,0,5)
#@gimp : Tensor smoothness = float(1.2,0,5)
#@gimp : note = note("<small><b>Note :</b>
#@gimp : This filter tries to reconstruct the content of image regions.
#@gimp : The inpainted region is defined as a white area in the top layer.
#@gimp : </small>")
gimp_inpaint :
  -if {@#==1} -return -endif
  -if $1 -inpaint_flow $2,$3,$4,-$5,-$6 -c 0,255 -else -inpaint[1--1] [0] -endif
  -to_rgba[0] -f[0] 0

gimp_inpaint_preview :
  -if {@#==1} -return -endif
  -gimp_inpaint $* -rm[0]

#@gimp Deinterlace : deinterlace, gimp_deinterlace(0)
#@gimp : Algorithm = choice("Standard","Motion-compensated")
gimp_deinterlace :
  -deinterlace 0 -skip $*

#@gimp Red-Eye attenuation : red_eye, red_eye
#@gimp : Threshold = float(75,0,100)
#@gimp : Smoothness = float(3.5,0,20)
#@gimp : Factor = float(0.1,0,1)

#@gimp Scale2x algorithm : gimp_scalenx, gimp_scalenx_preview(0)
#@gimp : Scaling factor = choice("x 2","x 3","x 4","x 6","x 8","x 9","x 12","x 16","x 18","x 27")
#@gimp : note = note{"\n<small><b>Note : </b>
#@gimp : This filter re-implements the scaling algorithm described at :
#@gimp : </small>"}
#@gimp : note = link("http://scale2x.sourceforge.net")
#@gimp : note = note{"<small>
#@gimp : This filter is useful for resizing images that have very few colors
#@gimp : (e.g. indexed images). It is generally useless for true colors images.
#@gimp : </small>"}
gimp_scalenx :
  -if {$1==0} -resize2x
  -elif {$1==1} -resize3x
  -elif {$1==2} -resize2x -resize2x
  -elif {$1==3} -resize3x -resize2x
  -elif {$1==4} -resize2x -resize2x -resize2x
  -elif {$1==5} -resize3x -resize3x
  -elif {$1==6} -resize3x -resize2x -resize2x
  -elif {$1==7} -resize2x -resize2x -resize2x -resize2x
  -elif {$1==8} -resize3x -resize3x -resize2x
  -elif {$1==9} -resize3x -resize3x -resize3x
  -endif

gimp_scalenx_preview :
  -crop 40%,40%,60%,60% -gimp_scalenx $1

#@gimp Smart upscale : gimp_upscale_smart, gimp_upscale_smart_preview(0)
#@gimp : Width = text("200%")
#@gimp : Height = text("200%")
#@gimp : Smoothness = float(2,0,20)
#@gimp : Anisotropy = float(0.4,0,1)
#@gimp : Sharpness = float(10,0,100)
gimp_upscale_smart :
  -upscale_smart $1,$2,1,$3,$4,$5 -cut 0,255

gimp_upscale_smart_preview :
  -repeat @#
    --r $1,$2,1,1,0
    -if {@{-1,w}<@{-2,w}||@{-1,h}<@{-2,h}}  # Test for downscaling
      -rm[-1] {@{-1,w}+1-(@{-1,w}%2)},{@{-1,h}+1-(@{-1,h}%2)},1,1,96,128
      -text[-1] "Downscaling is\nnot allowed !",5,5,16,1,255
      -rm[-2] -return
    -endif
    -p {@{-2,w}/@{-1,w}*100}%,{@{-2,h}/@{-1,h}*100}% -rm[-1]
    -crop 0,0,~-1 -pp[-1] -gimp_upscale_smart $1,$2,$3,$4,$5 -cut 0,255
  -mv[-1] 0 -done

#@gimp _<b>Layers</b>
#---------------------


#@gimp Average : compose_average, compose_average
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.
#@gimp : </small>"}

#@gimp Multiply : compose_multiply, compose_multiply
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.
#@gimp : </small>"}

#@gimp Screen : compose_screen, compose_screen
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.
#@gimp : </small>"}

#@gimp Darken : compose_darken, compose_darken
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.
#@gimp : </small>"}

#@gimp Lighten : compose_lighten, compose_lighten
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.
#@gimp : </small>"}

#@gimp Difference : compose_difference, compose_difference
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.
#@gimp : </small>"}

#@gimp Negation : compose_negation, compose_negation
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.
#@gimp : </small>"}

#@gimp Exclusion : compose_exclusion, compose_exclusion
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.
#@gimp : </small>"}

#@gimp Overlay : compose_overlay, compose_overlay
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.
#@gimp : </small>"}

#@gimp Hard light : compose_hardlight, compose_hardlight
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.
#@gimp : </small>"}

#@gimp Soft light : compose_softlight, compose_softlight
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.
#@gimp : </small>"}

#@gimp Dodge : compose_dodge, compose_dodge
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.
#@gimp : </small>"}

#@gimp Color burn : compose_colorburn, compose_colorburn
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.
#@gimp : </small>"}

#@gimp Reflect : compose_reflect, compose_reflect
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.
#@gimp : </small>"}

#@gimp Freeze : compose_freeze, compose_freeze
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.
#@gimp : </small>"}

#@gimp Stamp : compose_stamp, compose_stamp
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.
#@gimp : </small>"}

#@gimp Interpolation : compose_interpolation, compose_interpolation
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.
#@gimp : </small>"}

#@gimp XOR : compose_xor, compose_xor
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.
#@gimp : </small>"}

#@gimp Fade : gimp_compose_fade, gimp_compose_fade(1)
#@gimp : Preset = choice{1,"Custom","Linear","Circular","Wave","Keftales"}
#@gimp : Offset = float(0,-1,1)
#@gimp : Thinness = float(0,0,10)
#@gimp : Sharpness = float(5,1,20)
#@gimp : Sharpest = bool(0)
#@gimp : Revert layers = bool(0)
#@gimp : Note = note{\n<small>
#@gimp : The parameters below are used in most presets.
#@gimp : </small>}
#@gimp : 1st parameter = float(0,-1,1)
#@gimp : 2nd parameter = float(0,-1,1)
#@gimp : 3rd parameter = float(0,-1,1)
#@gimp : Note = note{\n<small>
#@gimp : The formula below is used for the <i>Custom</i> preset.
#@gimp : </small>}
#@gimp : Formula = text{"cos(4*pi*x/w) * sin(4*pi*y/h)"}
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.
#@gimp : </small>"}
gimp_compose_fade :
  -if {@#==1} -return -endif
  -to_colormode 4
  -if {$1==0} [0],[0],1,1,"$10"
  -else -_gimp_compose_fade$1 $7,$8,$9 -r[-1] [0],[0],1,1,3
  -endif
  -n[-1] {-(@#-2)*$3},{(@#-2)*(1+$3)}
  --[-1] {$2*(1+$3)*(@#-2)}
  -c[-1] 0,{@#-2}
  -if $6 -reverse[0--2] -endif
  -if $5 -round[-1] 1
  -else -roundify[-1] $4
  -endif
  -compose_fade
  -c 0,255

_gimp_compose_fade1 : [0],[0],1,1,"a=$1*pi/2; x*cos(a) + y*sin(a)"
_gimp_compose_fade2 : [0],[0],1,1,0 -=[-1] 1,{($1+1)*50}%,{($2+1)*50}% -distance[-1] 1
_gimp_compose_fade3 : [0],[0],1,1,0 -=[-1] 1,{($1+1)*50}%,{($2+1)*50}% -distance[-1] 1 -*[-1] {0.01+$3/2} -cos[-1]
_gimp_compose_fade4 : [0],[0],1,1,"((x-w*($1+0.5))*(y-h*($2+0.5)))%(0.2*w*h*(1.001+$3))"

#@gimp Edges merging : compose_edges, compose_edges(0)
#@gimp : Smoothness = float(0.8,0,5)
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.
#@gimp : </small>"}

#@gimp Transparent difference : gimp_transparent_diff, gimp_transparent_diff(1)
#@gimp : Threshold = float(1,0,100)
#@gimp : Smoothness = float(0,0,10)
#@gimp : Opaque pixels = choice(0,"From 1st layer","From 2nd layer")
#@gimp : Transparent pixels = choice(1,"From same values","From different values")
gimp_transparent_diff :
  -repeat {@#/2}
    -if $3
      --[-2] [-1] -norm[-2] -blur[-2] $2% -t[-2] $1% -reverse[-2,-1]
    -else
      --[-1] [-2] -norm[-1] -blur[-1] $2% -t[-1] $1%
    -endif
    -if {!$4} -negative[-1] -endif
    -to_rgba[-2] -*[-2,-1]
  -mv[-1] 0 -done

#@gimp Frequency merging : gimp_compose_freq, gimp_compose_freq(1)
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.
#@gimp : </small>"}
gimp_compose_freq :
  -v - -repeat {@#/2}
    --[-1] 128 -*[-1] 2 -+[-2,-1] -c[-1] 0,255
  -mv[-1] 0 -done -v +

#@gimp Frequency splitting : gimp_split_freq, gimp_split_freq_preview(1)
#@gimp : Smoothness = float(3,0,20)
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter splits an image layer into two layers, one containing the low frequencies (colors), the other with the high frequencies (contours). You can thus process each layer separatly, then recompose them with the previous <b>Frequency merging</b> filter.
#@gimp : </small>"}
gimp_split_freq_preview :
  -gimp_split_freq $1 -k[0,1] -a x

gimp_split_freq :
  -v - -repeat @#
    --blur[-1] $1 --[-2] [-1] -/[-2] 2 -+[-2] 128 -reverse[-2,-1]
  -mv[-2,-1] 0 -done -v +

#@gimp Layers alignment : gimp_align_layers, gimp_align_layers_preview
#@gimp : Alignment type = choice(0,"Rigid","Non-rigid")
#@gimp : Smoothness = float(0.7,0,1)
#@gimp : Scales = choice(0,"Auto","1","2","3","4","5","6","7","8")
gimp_align_layers :
  -remove_opacity
  -if $1 -register_nonrigid $2,0.1,$3
  -else ($2) -*[-1] 3 -register_rigid[0--2] @-1 -rm[-1]
  -endif

gimp_align_layers_preview :
  -gimp_align_layers $1,$2,0 -compose_edges 0.1

#@gimp Layers morphing : gimp_morph, _none_
#@gimp : Frames = _int(10,2,100)
#@gimp : Smoothness = _float(0.2,0,2)
#@gimp : Precision = _float(0.1,0,2)
gimp_morph :
  -to_rgb -morph $1,$2,$3

#@gimp Tiles to layers : split_tiles, gimp_split_tiles(1)
#@gimp : X-tiles = int(3,1,100)
#@gimp : Y-tiles = int(3,1,100)
#@gimp : Homogeneous tiles = _bool(false)
gimp_split_tiles :
  -split_tiles $1,$2,$3 -k[50%]

#@gimp Layers to tiles : append_tiles, gimp_append_tiles_preview(1)
#@gimp : X-tiles = int(3,1,100)
#@gimp : Y-tiles = int(3,1,100)
gimp_append_tiles_preview :
  -frame 1,1,0,0,0,255 -append_tiles $1,$2


#@gimp _<b>Patterns</b>
#-----------------------


#@gimp Random puzzle : gimp_puzzle, gimp_puzzle(0)
#@gimp : Scale = float(6,1,20)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","AB-components","A-component","B-component","Hue","Saturation","Value","Key","Alpha")
gimp_puzzle :
  -apply_channels "-puzzle $1",$2,0

#@gimp Mosaic pattern : gimp_mosaic, gimp_mosaic(0)
#@gimp : Density = float(1,0.1,10)
#@gimp : Amplitude = float(-80,-255,255)
#@gimp : Relief = bool(true)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","AB-components","A-component","B-component","Hue","Saturation","Value","Key","Alpha")
gimp_mosaic :
  -apply_channels "-mosaic $1,$2,$3",$4,0

#@gimp Whirls texture : gimp_whirls, gimp_whirls(0)
#@gimp : Density = int(7,3,20)
#@gimp : Smoothness = float(2,0,10)
#@gimp : Darkness = float(0.2,0,1)
#@gimp : Lightness = float(1.8,1,3)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","AB-components","A-component","B-component","Hue","Saturation","Value","Key","Alpha")
gimp_whirls :
  -apply_channels "-whirls $1,$2,$3,$4",$5,0

#@gimp Paper texture : gimp_paper_texture, gimp_paper_texture(0)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","AB-components","A-component","B-component","Hue","Saturation","Value","Key","Alpha")
gimp_paper_texture :
  -apply_channels "-paper_texture",$1,0

#@gimp Hearts : gimp_hearts, gimp_hearts(0)
#@gimp : Density = float(10,0,100)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","AB-components","A-component","B-component","Hue","Saturation","Value","Key","Alpha")
gimp_hearts :
  -apply_channels "-hearts $1",$2,0

#@gimp Sponge effect : gimp_sponge, gimp_sponge(0)
#@gimp : Size = int(13,3,21)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","AB-components","A-component","B-component","Hue","Saturation","Value","Key","Alpha")
gimp_sponge :
  -apply_channels "-sponge $1",$2,0

#@gimp Canvas effect : gimp_canvas, gimp_canvas(0)
#@gimp : note = note{"<b>First direction :</b>"}
#@gimp : Amplitude = float(70,0,300)
#@gimp : Angle = float(45,0,180)
#@gimp : Sharpness = float(400,0,2000)
#@gimp : note = note{"\n<b>Second direction : </b>"}
#@gimp : Activate second direction = bool(true)
#@gimp : Amplitude = float(70,0,300)
#@gimp : Angle = float(135,0,180)
#@gimp : Sharpness = float(400,0,2000)
gimp_canvas :
  -repeat @# -l[-1]
    -if $4
      ({cos($2*pi/180)}^{sin($2*pi/180)}) -vector2tensor[-1] -r[-1] [-2],[-2] --smooth[-2] [-1],$1 -rm[-2] -sharpen[-1] $3 -c[-1] 0,255
      ({cos($6*pi/180)}^{sin($6*pi/180)}) -vector2tensor[-1] -r[-1] [-2],[-2] -smooth[-3] [-1],$5 -rm[-1] -sharpen[-2] $7 -c[-2] 0,255 -+[-2,-1] -/[-1] 2
    -else
      ({cos($2*pi/180)}^{sin($2*pi/180)}) -vector2tensor[-1] -r[-1] [-2],[-2] -smooth[-2] [-1],$1 -rm[-1] -sharpen[-1] $3 -c[-1] 0,255
    -endif
  -endl -mv[-1] 0 -done


#@gimp _<b>Presets</b>
#----------------------


#@gimp PhotoComiX smoothing : gimp_anisotropic_smoothing, gimp_anisotropic_smoothing(0)
#@gimp : Amplitude = float(60,0,1000)
#@gimp : Sharpness = float(0.16,0,2)
#@gimp : Anisotropy = float(0.63,0,1)
#@gimp : Gradient smoothness = float(0.6,0,10)
#@gimp : Tensor smoothness = float(2.35,0,10)
#@gimp : Spatial precision = float(0.8,0.1,2)
#@gimp : Angular precision = float(30,1,180)
#@gimp : Value precision = float(2,0.1,5)
#@gimp : Interpolation = choice(0,"Nearest neighbor","Linear","Runge-Kutta")
#@gimp : Fast approximation = bool(1)
#@gimp : Iterations = int(1,1,10)
#@gimp : Channel(s) = choice("RGB","Luminance","Blue & Red chrominances","Blue chrominance","Red chrominance")
#@gimp : Tiles = int(1,1,10)
#@gimp : note = note{"\n<small><b>Note : </b>This set of anisotropic smoothing parameters has been suggested by PhotoComiX.</small>"}

#@gimp Thin brush smoothing : gimp_anisotropic_smoothing, gimp_anisotropic_smoothing(0)
#@gimp : Amplitude = float(60,0,1000)
#@gimp : Sharpness = float(0.9,0,2)
#@gimp : Anisotropy = float(0.64,0,1)
#@gimp : Gradient smoothness = float(3.1,0,10)
#@gimp : Tensor smoothness = float(1.10,0,10)
#@gimp : Spatial precision = float(0.8,0.1,2)
#@gimp : Angular precision = float(30,1,180)
#@gimp : Value precision = float(2,0.1,5)
#@gimp : Interpolation = choice(0,"Nearest neighbor","Linear","Runge-Kutta")
#@gimp : Fast approximation = bool(1)
#@gimp : Iterations = int(1,1,10)
#@gimp : Channel(s) = choice("RGB","Luminance","Blue & Red chrominances","Blue chrominance","Red chrominance")
#@gimp : Tiles = int(1,1,10)
#@gimp : note = note{"\n<small><b>Note : </b>This set of anisotropic smoothing parameters has been suggested by PhotoComiX.</small>"}


#@gimp _<b>Rendering</b>
#------------------------


#@gimp 3D elevation : gimp_elevation, gimp_elevation_preview(1)
#@gimp : Width = _int(512,8,1024)
#@gimp : Height = _int(512,8,1024)
#@gimp : Scale = float(0.05,-0.2,0.2)
#@gimp : Smoothness = float(1,0,10)
#@gimp : X-angle = float(50,-90,90)
#@gimp : Y-angle = float(0,0,360)
#@gimp : Zoom = float(1,0.1,4)
#@gimp : Rendering = choice(4,"Points","Lines","Flat","Flat shaded","Gouraud","Phong")
#@gimp : Opacity = float(1,0,1)
#@gimp : Focale = float(500,100,800)
#@gimp : note = note{"<small><b>Note :</b>
#@gimp : Use two input layers to define an elevation map that is different from
#@gimp : the image itself.
#@gimp : </small>"}
gimp_elevation :
  -if {@#==0} -q
  -elif {@#==1} --norm
  -else -k[0,1] -reverse
  -endif
  -to_rgb[0] -norm[1] -blur[1] $4 -*[1] $3 -r $1,$2,1,100%,3 -elevation3d[0] [1] -rm[1]
  -c3d -rot3d 0,0,1,$6 -rot3d 1,0,0,$5 -*3d $7 -m3d $8 -f3d $10
  $1,$2,1,4,-1 -object3d[-1] [0],50%,50%,0,$9 -rm[0]
  -s c -t[-1] 0 -*[-1] 255 -a c

gimp_elevation_preview :
  -if {@#==0} -q -endif
  -gimp_elevation @{-1,w},@{-1,h},$3,$4,$5,$6,$7,$8,$9,$10

#@gimp 3D image object : gimp_imageobject3d, gimp_imageobject3d(1)
#@gimp : Type = choice("Cube","Pyramid")
#@gimp : Width = int(512,1,1024)
#@gimp : Height = int(512,1,1024)
#@gimp : Size = float(256,0,512)
#@gimp : X-angle = float(57,0,360)
#@gimp : Y-angle = float(41,0,360)
#@gimp : Z-angle = float(21,0,360)
gimp_imageobject3d :
  -repeat @# -l[@{>,-1}]
    -to_rgba
    -_gimp_imageobject3d_$1
    -c3d
    -*3d $4 -rot3d 0,0,1,$7 -rot3d 0,1,0,$6 -rot3d 1,0,0,$5 -m3d 2 -db3d 0
    $2,$3,1,4,-1 -object3d[1] [0],50%,50% -k[1]
    -s[-1] c -t[-1] 0 -*[-1] 255 -a[-4--1] c
  -endl -done

_gimp_imageobject3d_0 : -imagecube3d
_gimp_imageobject3d_1 : -imagepyramid3d

#@gimp 3D random objects : gimp_random3d, gimp_random3d(1)
#@gimp : Type = choice("Cube","Cone","Cylinder","Sphere","Torus")
#@gimp : Density = int(50,1,300)
#@gimp : Size = float(3,1,20)
#@gimp : Z-range = float(100,0,300)
#@gimp : Rendering = choice(3,"Points","Lines","Flat","Flat shaded","Gouraud","Phong")
#@gimp : Opacity = float(1,0,1)
_gimp_random3d0 : -box3d $1
_gimp_random3d1 : ($1) -/[-1] 2 -cone3d @-1,$1 -rm[-2]
_gimp_random3d2 : ($1) -/[-1] 2 -cylinder3d @-1,$1 -rm[-2]
_gimp_random3d3 : -sphere3d $1,2
_gimp_random3d4 : ($1) -/[-1] 3 -torus3d $1,@-1 -rm[-2]
gimp_random3d :
  -m3d $5 -db3d 0
  -repeat @# -l[@{>,-1}]
    -to_rgb (@{-1,w},@{-1,h},@{-1,d},@{-1,s}) -/[-1] 2 -repeat $2
    (@{1,0}) -+[-1] @{1,1} -*[-1] $3 -/[-1] 100 -_gimp_random3d$1 @-1 -rm[-2]
    -rot3d[-1] 1,1,0,{?(0,360)}
    ({?(-1,1)}) -*[-1] @{1,0} ({?(-1,1)}) -*[-1] @{1,1}
    -+3d[-3] @-2,@-1,{?(-$4,$4)} -rm[-2,-1]
    -col3d[-1] {?(255)},{?(255)},{?(255)} -done -+3d[2--1] -object3d[0] [-1],50%,50%,0,$6,1
    -k[0]
  -endl -done

#@gimp Mandelbrot / Julia sets : gimp_mandelbrot, gimp_mandelbrot_preview
#@gimp : X-center = float(0,-2,2)
#@gimp : Y-center = float(0,-2,2)
#@gimp : Zoom = float(0,0,100)
#@gimp : Iterations = int(128,1,512)
#@gimp : Fractal set = choice(Mandelbrot, Julia)
#@gimp : X-seed (Julia) = text("0.317")
#@gimp : Y-seed (Julia) = text("0.03")
#@gimp : Color 1 = color(0,0,255)
#@gimp : Color 2 = color(0,255,0)
#@gimp : Color 3 = color(255,0,0)
#@gimp : Color 4 = color(255,0,255)
gimp_mandelbrot :
  (0^0^0) ($8^$9^$10) ($11^$12^$13) ($14^$15^$16) ($17^$18^$19)
  -a[-4--1] x -r[-1] $4,1,1,3,3 -a[-2,-1] x -mv[-1] 0
  -repeat {@#-1}
    -p @{-1,w},@{-1,h} -rm[-1] ~-1 -pp[-1]
    -mandelbrot[-1] {$1-2/(1+$3)},{$2-2/(1+$3)},{$1+2/(1+$3)},{$2+2/(1+$3)},$4,$5,{if($5,$6,0)},{if($5,$7,0)}
    -map[-1] [0]
  -mv[-1] 1 -done -rm[0]

gimp_mandelbrot_preview :
  -gimp_mandelbrot $*
  -line 0,50%,100%,50%,0.5,255
  -line 50%,0,50%,100%,0.5,255

#@gimp _<b>Sequences</b>
#-----------------------

gimp_animate_preview : -skip ${4=1}
  -i[0] ({@{-1,w}/2},@{-1,h})
  -repeat {@#-1}
    -if $4 -s[-1] x,2 -else [-1] -endif
    -i $2 -i $3 -$1[-4] @-2 -$1[-3] @-1 -rm[-2,-1]
    -if {!$4} -columns[-2] 0,{@{-2,w}/2} -columns[-1] {@{-1,w}/2+1},100% -endif
    -r[-2,-1] @0,100%,100%,2 -a[-2,-1] x -drgba[-1]
    -line[-1] 50%,0,50%,100%,1,0,0,0,255
    34,11 -text[-1] "Start",2,0,13,1,1 --dilate[-1] 5 -to_colormode[-2] @{-3,s} -*[-2] 255 -image[-3] [-2],2,2,0,0,1,[-1] -rm[-2--1]
    21,12 -text[-1] "End",2,1,13,1,1 --dilate[-1] 5 -to_colormode[-2] @{-3,s} -*[-2] 255 -image[-3] [-2],{@{-3,w}-22},{@{-3,h}-13},0,0,1,[-1] -rm[-2--1]
  -mv[-1] 1 -done -rm[0]

#@gimp Polaroid : gimp_animate_polaroid, gimp_animate_polaroid_preview(1)
#@gimp : Frames = _int(10,2,100)
#@gimp : Output frames = _bool(1)
#@gimp : Output files = _bool(0)
#@gimp : Output folder = _folder()
#@gimp : note = note{"\n<b>Starting parameters :</b>"}
#@gimp : Frame size = int(10,1,400)
#@gimp : Bottom size = int(20,1,400)
#@gimp : X-shadow = float(0,-20,20)
#@gimp : Y-shadow = float(0,-20,20)
#@gimp : Smoothness = float(3,0,5)
#@gimp : Angle = float(0,0,360)
#@gimp : Zoom = float(1,0.01,1)
#@gimp : note = note{"\n<b>Ending parameters :</b>"}
#@gimp : Frame size = int(10,1,400)
#@gimp : Bottom size = int(20,1,400)
#@gimp : X-shadow = float(0,-20,20)
#@gimp : Y-shadow = float(0,-20,20)
#@gimp : Smoothness = float(3,0,5)
#@gimp : Angle = float(20,0,360)
#@gimp : Zoom = float(1,0.01,1)
_gimp_polaroid :
  -gimp_polaroid {round($1)},{round($2)},$3,$4,$5,$6 -zoom $7,0.5,0.5,0,0

gimp_animate_polaroid_preview :
  -gimp_animate_preview _gimp_polaroid,($5;$6;$7;$8;$9;$10;$11),($12;$13;$14;$15;$16;$17;$18),0

gimp_animate_polaroid :
  -animate _gimp_polaroid,($5;$6;$7;$8;$9;$10;$11),($12;$13;$14;$15;$16;$17;$18),$1,$2,$3,"$4/gmic_polaroid"
  -push_maxsize -r ~-1,0,0,0.5,0.5 -pp[-1]

#@gimp Edges : gimp_animate_edges, gimp_animate_edges_preview(0)
#@gimp : Frames = _int(10,2,100)
#@gimp : Output frames = _bool(1)
#@gimp : Output files = _bool(0)
#@gimp : Output folder = _folder()
#@gimp : note = note{"\n<b>Starting parameters :</b>"}
#@gimp : Smoothness = float(0,0,10)
#@gimp : Edge threshold = float(10,0,30)
#@gimp : note = note{"\n<b>Ending parameters :</b>"}
#@gimp : Smoothness = float(0,0,10)
#@gimp : Edge threshold = float(30,0,30)
#@gimp : note = note{"\n<b>Global parameters :</b>"}
#@gimp : Negative colors = bool(0)
gimp_animate_edges_preview :
  -gimp_animate_preview gimp_edges,($5;$6;$9),($7;$8;$9)

gimp_animate_edges :
  -animate gimp_edges,($5;$6;$9),($7;$8;$9),$1,$2,$3,"$4/gmic_edges"

#@gimp Cartoon : gimp_animate_cartoon, gimp_animate_cartoon_preview(0)
#@gimp : Frames = _int(10,2,100)
#@gimp : Output frames = _bool(1)
#@gimp : Output files = _bool(0)
#@gimp : Output folder = _folder()
#@gimp : note = note{"\n<b>Starting parameters :</b>"}
#@gimp : Smoothness = float(0.5,0,2)
#@gimp : Sharpening = float(200,0,400)
#@gimp : Edge threshold = float(10,1,30)
#@gimp : Edge thickness = float(0.1,0,1)
#@gimp : Color strength = float(1.5,0,3)
#@gimp : note = note{"\n<b>Ending parameters :</b>"}
#@gimp : Smoothness = float(3,0,2)
#@gimp : Sharpening = float(200,0,400)
#@gimp : Edge threshold = float(10,1,30)
#@gimp : Edge thickness = float(0.1,0,1)
#@gimp : Color strength = float(1.5,0,3)
#@gimp : note = note{"\n<b>Global parameters :</b>"}
#@gimp : Color quantization = int(4,2,256)
gimp_animate_cartoon_preview :
  -gimp_animate_preview cartoon,($5;$6;$7;$8;$9;$15),($10;$11;$12;$13;$14;$15)

gimp_animate_cartoon :
  -animate cartoon,($5;$6;$7;$8;$9;$15),($10;$11;$12;$13;$14;$15),$1,$2,$3,"$4/gmic_cartoon"

#@gimp B&amp;W stencil : gimp_animate_stencilbw, gimp_animate_stencilbw_preview(1)
#@gimp : Frames = _int(10,2,100)
#@gimp : Output frames = _bool(1)
#@gimp : Output files = _bool(0)
#@gimp : Output folder = _folder()
#@gimp : note = note{"\n<b>Starting parameters :</b>"}
#@gimp : Edge threshold = float(10,0,30)
#@gimp : Smoothness = float(10,0,30)
#@gimp : note = note{"\n<b>Ending parameters :</b>"}
#@gimp : Edge threshold = float(10,0,30)
#@gimp : Smoothness = float(20,0,30)
gimp_animate_stencilbw_preview :
  -gimp_animate_preview stencilbw,($5;$6),($7;$8)

gimp_animate_stencilbw :
  -animate stencilbw,($5;$6),($7;$8),$1,$2,$3,"$4/gmic_stencilbw"

#@gimp B&amp;W pencil : gimp_animate_pencilbw, gimp_animate_pencilbw_preview(0)
#@gimp : Frames = _int(10,2,100)
#@gimp : Output frames = _bool(1)
#@gimp : Output files = _bool(0)
#@gimp : Output folder = _folder()
#@gimp : note = note{"\n<b>Starting parameters :</b>"}
#@gimp : Pencil type = float(2.3,0,5)
#@gimp : Amplitude = float(100,0,200)
#@gimp : note = note{"\n<b>Ending parameters :</b>"}
#@gimp : Pencil type = float(0.3,0,5)
#@gimp : Amplitude = float(60,0,200)
gimp_animate_pencilbw_preview :
  -gimp_animate_preview pencilbw,($5;$6),($7;$8)

gimp_animate_pencilbw :
  -animate pencilbw,($5;$6),($7;$8),$1,$2,$3,"$4/gmic_pencilbw"

#@gimp Soft glow : gimp_animate_glow, gimp_animate_glow_preview(1)
#@gimp : Frames = _int(10,2,100)
#@gimp : Output as frames = _bool(1)
#@gimp : Output as files = _bool(0)
#@gimp : Output folder = _folder()
#@gimp : note = note{"\n<b>Starting parameters :</b>"}
#@gimp : Amplitude = float(0,0,8)
#@gimp : note = note{"\n<b>Ending parameters :</b>"}
#@gimp : Amplitude = float(3,0,8)
gimp_animate_glow_preview :
  -gimp_animate_preview glow,($5),($6)

gimp_animate_glow :
  -animate glow,($5),($6),$1,$2,$3,"$4/gmic_glow"

#@gimp Morphological filter : gimp_animate_morpho, gimp_animate_morpho_preview(0)
#@gimp : Frames = _int(10,2,100)
#@gimp : Output as frames = _bool(1)
#@gimp : Output as files = _bool(0)
#@gimp : Output folder = _folder()
#@gimp : note = note{"\n<b>Starting parameters :</b>"}
#@gimp : Size = int(150,2,200)
#@gimp : note = note{"\n<b>Ending parameters :</b>"}
#@gimp : Size = int(1,1,200)
#@gimp : note = note{"\n<b>Global parameters :</b>"}
#@gimp : Action = choice("Erosion","Dilation","Opening","Closing",
#@gimp : "Original - Erosion","Original - Dilation","Original - Opening","Original - Closing")
#@gimp : Invert colors = bool(false)
gimp_animate_morpho_preview :
  -gimp_animate_preview gimp_morpho,($7;$5;$8),($7;$6;$8),0

_gimp_morpho :
  -gimp_morpho $1,{round($2)},$3

gimp_animate_morpho :
  -animate _gimp_morpho,($7;$5;$8),($7;$6;$8),$1,$2,$3,"$4/gmic_morpho"

#@gimp 3D elevation : gimp_elevation_anim, gimp_elevation_anim_preview(1)
#@gimp : Width = _int(512,8,1024)
#@gimp : Height = _int(512,8,1024)
#@gimp : Scale = float(0.05,-0.2,0.2)
#@gimp : Smoothness = float(1,0,10)
#@gimp : X-angle = float(50,-90,90)
#@gimp : Rotation step = float(5,1,90)
#@gimp : Zoom = float(1,0.1,4)
#@gimp : Rendering = choice(4,"Points","Lines","Flat","Flat shaded","Gouraud","Phong")
#@gimp : Opacity = float(1,0,1)
#@gimp : Focale = float(500,100,800)
#@gimp : Frames = int(10,1,360)
#@gimp : note = note{"<small><b>Note :</b>
#@gimp : Use two input layers to define an elevation map that is different from
#@gimp : the image itself.
#@gimp : </small>"}
gimp_elevation_anim :
  -if {@#==0} -q
  -elif {@#==1} --norm
  -else -k[0,1] -reverse
  -endif
  -to_rgb[0] -norm[1] -blur[1] $4 -*[1] $3 -r $1,$2,1,100%,3 -elevation3d[0] [1] -rm[1]
  -c3d -*3d $7 -m3d $8 -f3d $10
  -repeat $11
    --rot3d[0] 1,0,0,$5
    $1,$2,1,4,-1 -object3d[-1] [-2],50%,50%,0,$9 -rm[-2]
    -s[-1] c -t[-1] 0 -*[-1] 255 -a[-4--1] c
    -rot3d[0] 0,0,1,$6
  -done -rm[0]

gimp_elevation_anim_preview :
  -if {@#==0} -q -endif
  -gimp_elevation_preview @{-1,w},@{-1,h},$3,$4,$5,0,$7,$8,$9,$10

#@gimp 3D image cube : gimp_animate_imagecube3d, gimp_animate_imagecube3d_preview(1)
#@gimp : Frames = _int(10,2,100)
#@gimp : Output as frames = _bool(1)
#@gimp : Output as files = _bool(0)
#@gimp : Output folder = _folder()
#@gimp : note = note{"\n<b>Starting parameters :</b>"}
#@gimp : Cube size = float(128,0,512)
#@gimp : X-angle = float(57,0,1440)
#@gimp : Y-angle = float(41,0,1440)
#@gimp : Z-angle = float(21,0,1440)
#@gimp : note = note{"\n<b>Ending parameters :</b>"}
#@gimp : Cube size = float(128,0,512)
#@gimp : X-angle = float(417,0,1440)
#@gimp : Y-angle = float(41,0,1440)
#@gimp : Z-angle = float(741,0,1440)
#@gimp : note = note{"\n<b>Global parameters :</b>"}
#@gimp : Rendering width = int(256,1,1024)
#@gimp : Rendering height = int(256,1,1024)
#@gimp : Image resolution = int(128,1,512)
gimp_animate_imagecube3d_preview :
  -k[50%] -gimp_animate_preview gimp_imagecube3d,($13;$14;$15;$5;$6;$7;$8),($13;$14;$15;$9;$10;$11;$12),0

gimp_animate_imagecube3d :
  -animate gimp_imagecube3d,($13;$14;$15;$5;$6;$7;$8),($13;$14;$15;$9;$10;$11;$12),$1,$2,$3,"$4/gmic_cube3d"

#@gimp Anisotropic smoothing : gimp_animate_anisotropic_smoothing, gimp_animate_anisotropic_smoothing_preview(0)
#@gimp : Frames = _int(10,2,100)
#@gimp : Output as frames = _bool(1)
#@gimp : Output as files = _bool(0)
#@gimp : Output folder = _folder()
#@gimp : note = note{"\n<b>Starting parameters :</b>"}
#@gimp : Amplitude = float(60,0,1000)
#@gimp : Sharpness = float(0.7,0,2)
#@gimp : Anisotropy = float(0.3,0,1)
#@gimp : Gradient smoothness = float(0.6,0,10)
#@gimp : Tensor smoothness = float(1.1,0,10)
#@gimp : note = note{"\n<b>Ending parameters :</b>"}
#@gimp : Amplitude = float(60,0,1000)
#@gimp : Sharpness = float(0.7,0,2)
#@gimp : Anisotropy = float(0.3,0,1)
#@gimp : Gradient smoothness = float(0.6,0,10)
#@gimp : Tensor smoothness = float(1.1,0,10)
#@gimp : note = note{"\n<b>Global parameters :</b>"}
#@gimp : Spatial precision = float(0.8,0.1,2)
#@gimp : Angular precision = float(30,1,180)
#@gimp : Value precision = float(2,0.1,5)
#@gimp : Interpolation type = choice(0,"Nearest neighbor","Linear","Runge-Kutta")
#@gimp : Fast approximation = bool(1)
#@gimp : Iterations = int(1,1,10)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Alpha")
#@gimp : Tile subdivisions = int(1,1,10)
gimp_animate_anisotropic_smoothing_preview :
  -gimp_animate_preview gimp_anisotropic_smoothing,($5;$6;$7;$8;$9;$15;$16;$17;$18;$19;$20;$21;$22),($10;$11;$12;$13;$14;$15;$16;$17;$18;$19;$20;$21;$22),0

gimp_animate_anisotropic_smoothing :
  -animate gimp_anisotropic_smoothing,($5;$6;$7;$8;$9;$15;$16;$17;$18;$19;$20;$21;$22),($10;$11;$12;$13;$14;$15;$16;$17;$18;$19;$20;$21;$22),$1,$2,$3,"$4/gmic_anisotropic_smoothing"


#@gimp _<b>Various</b>
#----------------------


#@gimp Fourier analysis : display_fft, display_fft(1)

#@gimp Histogram analysis : _none_, gimp_display_histogram(1)
#@gimp : Clusters = int(256,2,256)
#@gimp : Monochrome = bool(0)
gimp_display_histogram :
  -to_rgb -if $2 -luminance -endif
  -repeat @#
    -display_histogram[-1] @{-1,w},@{-1,h},$1,255
  -mv[-1] 0 -done

#@gimp Import data : gimp_import_image, gimp_no_preview
#@gimp : Filename = file()
#@gimp : Normalize = bool(1)
#@gimp : note = note{"\n<small><b>Note : </b>
#@gimp : This filter can import any image data read by the <b>G'MIC</b> language interpreter.
#@gimp : It includes exotic formats as : <i>Pandore, CImg, Inrimage, AVI/MPEG (requires FFMPEG installed), ...</i>
#@gimp : </small>"}
gimp_import_image :
  -rm -i "$1" -s z -if $2 -n 0,255 -else -c 0,255 -endif

#@gimp Custom G'MIC command : gimp_custom_command, gimp_custom_command
#@gimp : Command = text("-to_rgb --deform 20 -compose_edges 3")
#@gimp : Value range = choice("Cut","Normalize")
#@gimp : Enable channel processing = bool(0)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","AB-components","A-component","B-component","Hue","Saturation","Value","Key","Alpha")
#@gimp : note = note{"\n<small><b>Note : </b>
#@gimp : This filter can execute any set of instructions understood by the <b>G'MIC</b> language interpreter.
#@gimp : Here, you can then test some commands before creating your own G'MIC custom commands and GIMP menu entries.\n\n
#@gimp : Please look at the documentation reference web page :</small>"}
#@gimp : note = link("http://gmic.sourceforge.net/reference.shtml")
#@gimp : note = note{"<small>
#@gimp : to learn more about available <b>G'MIC</b> commands.
#@gimp : </small>"}
gimp_custom_command :
  -if $3
    -apply_channels "$1",$4,$2
  -else
    $1 -if $2 -n 0,255 -else -c 0,255 -endif
  -endif

#@gimp Quick copyright : gimp_quick_copyright, gimp_quick_copyright(0)
#@gimp : Text = text("\251 G'MIC")
#@gimp : Size = int(24,13,128)
#@gimp : Color           = color(255,255,255,128)
#@gimp : Outline = int(1,0,4)
#@gimp : Position = choice(3,"Up-left","Up-right","Bottom-left","Bottom-right")
#@gimp : Offset = int(5,0,40)
#@gimp : Orientation = choice(1,"-90 deg.","0 deg.","+90 deg.","+180 deg.")
gimp_quick_copyright :
  -i[0] 512,60,1,3 -text[0] "$1",0,0,$2,1,$3,$4,$5 -autocrop[0] 0 -r[0] {@{0,w}+2*$7},{@{0,h}+2*$7},1,3,0,0,0.5,0.5
  -i[1] 512,60,1,1 -text[1] "$1",0,0,$2,1,1 -autocrop[1] 0 -r[1] {@{1,w}+2*$7},{@{1,h}+2*$7},1,1,0,0,0.5,0.5 -dilate[1] {1+2*$7}
  -rotate[0,1] {90*($10-1)}
  -repeat {@#-2}
  -if {$8==0} -image[-1] [0],$9,$9,0,0,{$6/255},[1]
  -elif {$8==1} -image[-1] [0],{@{-1,w}-1-@{0,w}-$9},$9,0,0,{$6/255},[1]
  -elif {$8==2} -image[-1] [0],$9,{@{-1,h}-1-@{0,h}-$9},0,0,{$6/255},[1]
  -else -image[-1] [0],{@{-1,w}-1-@{0,w}-$9},{@{-1,h}-1-@{0,h}-$9},0,0,{$6/255},[1]
  -endif
  -mv[-1] 2 -done
  -rm[0,1]


#@gimp _<i>Initial G'MIC filters</i>
#-----------------------------------


#@gimp About this section : _none_, _none_
#@gimp : note = note{"
#@gimp : This section contains the implementations of all the <i>initial</i> filters,
#@gimp : <i>i.e.</i> the ones defined in the stable release archive of <b>G'MIC</b>.
#@gimp : They are kept, so that in case of updating problems, the original filters are still accessible.
#@gimp : If no entries appear below, then you did probably not update your filters definitions yet."}

# Local Variables:
# mode: sh
# End:
#
# (End of G'MIC custom commands)
